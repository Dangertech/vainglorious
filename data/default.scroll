std::vector<std::string> File::rblock()
{
	srand(time(0) + roff);
	int cho = rand()%blocks.size();
	roff++;
	return blocks[cho];
}

int File::crunch_file(std::string scroll_loc)
{
	std::ifstream scroll(scroll_loc);
	if (!scroll.is_open())
		return ERROR;
	std::string cur_line;
	std::vector<std::string> cur_block;
	while (getline(scroll, cur_line))
	{
		if (cur_line == "") // Block finished, push!
		{
			if (cur_block.size() > 0)
				blocks.push_back(cur_block);
			cur_block.clear();
		}
		else
		{
			cur_block.push_back(cur_line);
		}
	}
	// Push the last block before EOF
	if (cur_block.size() > 0)
		blocks.push_back(cur_block);
	scroll.close();
	return 0;
}

int main(int argc, char* argv[])
{
	std::cout << "Processing Arguments..." << std::endl;
	args.process(argc, argv);
	std::cout << "Target Scroll File Is: " << args.get_file() << std::endl;
	 
	std::cout << "Crunching through Scroll file..." << std::endl;
	if (scroll.crunch_file(args.get_file()) == ERROR)
		std::cout << "Error opening scroll! Please check file ownership!" << std::endl;
	std::cout << "Done!" << std::endl;
	std::cout << "Total blocks found: " << scroll.get_blocks().size() << std::endl;
	std::cout << scroll.get_blocks()[0][0] << std::endl; // Print the first line of the first block
	 
	// Check if dry run was specified
	if (args.get_dry())
		return 5;
	std::cout << "Initializing Display..." << std::endl;
	// initscr() starts here
	render.run(args, scroll);
}

int Render::run(Args my_args, File my_scroll)
{
	initscr();
	noecho(); // Turn off printing of pressed character
	int ch;
	std::vector<std::string> myblock;
	int blockpos = 0;
	while (1)
	{
		/* If everything in the block has been used,
		 * set new block and reset blockpos
		 */
		if (blockpos >= myblock.size())
		{
			myblock = my_scroll.rblock();
			blockpos = 0;
		}
		 
		ch = getch();
		if (ch == 4) // CTRL-D
			break;
		 
		printw("%s\n", myblock[blockpos].c_str());
		blockpos++;
	}
	endwin();
	return 0;
}

class Util
{
	public:
		template <typename T>
		int veccmp(T to_comp, std::vector<T> vec)
		{
			for (long unsigned int i = 0; i<vec.size(); i++)
			{
				if (to_comp == vec[i])
					return i;
			}
			return ERROR;
		}
} extern util;

void Args::process(int argc, char* argv[])
{
	for (int i = 1; i<argc; i++)
	{
		int match = util.veccmp<std::string>(std::string(argv[i]), switches);
		switch (match)
		{
			case 0:
				process_file(i, argc, argv);
				break;
			case 7:
				dry = true;
				break;
			default:
				std::cout << "Invalid argument!" << std::endl;
				break;
		}
	}
}

void Args::process_file(int &i, int argc, char* argv[])
{
	i++;
	file = argv[i];
}
