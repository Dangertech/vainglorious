std::vector<std::string> File::rblock()
{
	srand(time(0) + roff);
	int cho = rand()%blocks.size();
	roff++;
	return blocks[cho];
}

int File::crunch_file(std::string scroll_loc)
{
	std::ifstream scroll(scroll_loc);
	if (!scroll.is_open())
		return ERROR;
	std::string cur_line;
	std::vector<std::string> cur_block;
	while (getline(scroll, cur_line))
	{
		if (cur_line == "") // Block finished, push!
		{
			if (cur_block.size() > 0)
				blocks.push_back(cur_block);
			cur_block.clear();
		}
		else
		{
			cur_block.push_back(cur_line);
		}
	}
	// Push the last block before EOF
	if (cur_block.size() > 0)
		blocks.push_back(cur_block);
	scroll.close();
	return 0;
}

int main(int argc, char* argv[])
{
	std::cout << "Processing Arguments..." << std::endl;
	args.process(argc, argv);
	std::cout << "Target Scroll File Is: " << args.get_file() << std::endl;
	 
	std::cout << "Crunching through Scroll file..." << std::endl;
	if (scroll.crunch_file(args.get_file()) == ERROR)
		std::cout << "Error opening scroll! Please check file ownership!" << std::endl;
	std::cout << "Done!" << std::endl;
	std::cout << "Total blocks found: " << scroll.get_blocks().size() << std::endl;
	std::cout << scroll.get_blocks()[0][0] << std::endl; // Print the first line of the first block
	 
	// Check if dry run was specified
	if (args.get_dry())
		return 5;
	std::cout << "Initializing Display..." << std::endl;
	// initscr() starts here
	render.run(args, scroll);
}

int Render::run(Args my_args, File my_scroll)
{
	initscr();
	noecho(); // Turn off printing of pressed character
	int ch;
	std::vector<std::string> myblock;
	int blockpos = 0;
	while (1)
	{
		/* If everything in the block has been used,
		 * set new block and reset blockpos
		 */
		if (blockpos >= myblock.size())
		{
			myblock = my_scroll.rblock();
			blockpos = 0;
		}
		 
		ch = getch();
		if (ch == 4) // CTRL-D
			break;
		 
		printw("%s\n", myblock[blockpos].c_str());
		blockpos++;
	}
	endwin();
	return 0;
}

class Util
{
	public:
		template <typename T>
		int veccmp(T to_comp, std::vector<T> vec)
		{
			for (long unsigned int i = 0; i<vec.size(); i++)
			{
				if (to_comp == vec[i])
					return i;
			}
			return ERROR;
		}
} extern util;

void Args::process(int argc, char* argv[])
{
	for (int i = 1; i<argc; i++)
	{
		int match = util.veccmp<std::string>(std::string(argv[i]), switches);
		switch (match)
		{
			case 0:
				process_file(i, argc, argv);
				break;
			case 7:
				dry = true;
				break;
			default:
				std::cout << "Invalid argument!" << std::endl;
				break;
		}
	}
}

void Args::process_file(int &i, int argc, char* argv[])
{
	i++;
	file = argv[i];
}

class Args
{
	private:
		
		// Properties (accessible through public functions)
		 
		/* File to read blocks from */
		std::string file = DEF_FILE;
		/* Until where should the scroll file
		 * be read? -1 reads until the end
		 */
		int read_until = -1;
		/* How far down from the lower terminal border
		 * should the text be shown before scrolling up?
		 */
		int spacing = 1;
		/* How many lines should be left empty
		 * between individual blocks
		 */
		int limit = 4;
		/* Should the screen be cleared and redrawn
		 * from scratch every time it changes?
		 */
		bool forcedraw = false;
		
		/* Only get arguments and quit before initializing
		 * the ncurses display
		 */
		bool dry = false;
		
		// Color settings
		int themeid = 0;
		/* The background color is
		 * completely independent from
		 * the set theme; It is used by args::makepairs()
		 * to set the correct background color for every pair */
		// Uses rgb values from range 0 to 1000
		std::vector<int> bg_col = {0, 0, 0};
		/* if this is false, only color 0 from a theme will be used */
		bool multicol = true;
		/* Custom theme that is set if the user gives a valid colorfile */
		std::vector<Color> custom_theme = {};
		/* Custom cursor scheme set by the user */
		std::vector<unsigned char> custom_cur = {};
		bool show_cursor = true;
		
		// Movement style
		MovementBehaviour behaviour = INPUT;
		ProgressStyle style = WORD;
		int speed = 1;
		/* By default, the user can advance the
		 * text by 1 word per button press
		 */
		float auto_delay = 0.01; // Delay in seconds when behaviour is AUTO
		
		// Input management
		 
		std::vector<std::string> switches =
		{
			"-f",
			"--scrollfile",
			"--until",
			
			// General properties
			"-l",
			"--limit",
			"--spacing",
			"--forcedraw",
			 
			// Color related
			"-T",
			"--theme",
			"-F",
			"--colorfile",
			"-B",
			"--background",
			"-C",
			"--cursor",
			"-c",
			"--no-show-cursor",
			
			// Input related
			"-b",
			"--movement-behaviour",
			"-s",
			"--movement-style",
			"-S",
			"--movement-speed",
			"-d",
			"--movement-delay",
			 
			// Utilities
			"--debug",
			"--dry",
			"-h",
			"--help"
		};
		
		// Flag processors 
		 
		int process_file(int &i, int argc, char * argv[]);
		int process_until(int &i, int argc, char * argv[]);
		int process_limit(int &i, int argc, char * argv[]);
		int process_spacing(int &i, int argc, char * argv[]);
		 
		int process_theme(int &i, int argc, char * argv[]);
		/* Return values: Returns 0 if everything is OK,
		 * or the line number in which an error was encountered,
		 * starting at 1; Returns -1 if the file could not be opened
		 */
		int process_custom_theme(int &i, int argc, char * argv[]);
		int process_background(int &i, int argc, char * argv[]);
		int process_cursor(int &i, int argc, char * argv[]);
		
		std::vector<unsigned char> unify_color_input(std::string input);
		
		int process_behaviour(int &i, int argc, char * argv[]);
		int process_style(int &i, int argc, char * argv[]);
		int process_speed(int &i, int argc, char * argv[]);
		int process_auto_delay(int &i, int argc, char * argv[]);
		
		void show_help();
		
		
		// Error/Help messages
		 
		#define s(X) std::string(X)
		#define int_st(X) std::to_string(X)
		// Ugly bodge for err_msgs.at("theme");
		DefTheme listener;
		std::string print_themes()
		{
			std::string ret;
			std::vector<std::string> names = listener.get_themenames();
			for (int i = 0; i<names.size(); i++)
			{
				ret += "\t\t" + names[i] + "\n";
			}
			return ret;
		}
		std::unordered_map<std::string, std::string> err_msgs =
		{
			{"file",
				s("Usage of -f/--file:\n")
				+ "\tSpecify a file to get text blocks from;\n"
				+ "\tThe file should be cut in text BLOCKS, "
					+ "which are separated by empty lines.\n"
				+ "\tThe default scrollfile serves as an example.\n"
				+ "\t\tExample: '" + C_GREEN_U + "vain --file scrollfile.txt" + C_OFF + "'\n"
				+ "\t\tDefault: '" + file + "'\n"
			},
			{"colorfile",
				s("Usage of -F/--colorfile:\n")
				+ "\tMake vainglorious use a custom theme contained in a file;\n"
				+ "\t\tExample colorfile:\n"
				+ "\t\t\t#000000 \% First line defines background color\n"
				+ "\t\t\t\%Color, minimum length, maximum length, probability\n"
				+ "\t\t\t#38b27f, 3, 5, 5\n"
				+ "\t\t\t#6df1d8, 3, 4, 3\n"
				+ "\t\t\t92, 44, 109, 4, 6, 4 \% Color can be given either in HEX or RGB format\n"
				+ "\t\t\t#5da4a6, 4, 6, 4\n"
				+ "\t\t\t#b8aec8, 2, 5, 3\n"
				+ "\t\t\t#3c345c, 2, 3, 1\n"
				+ "\t\tUsage example: '" + C_GREEN_U + "vain --colorfile mytheme.txt"
					+ C_OFF + "'\n"
			},
			{"limit",
				s("Usage of -l/--limit:\n")
				+ "\tSet the bottom margin of the scrolling text;\n"
				+ "\t\tExample: '" + C_GREEN_U + "vain --limit 1" + C_OFF + "'\n"
				+ "\t\tDefault: " + int_st(limit) + "\n"
			},
			{"cursor",
				s("Usage of -C/--cursor:\n")
				+ "\tSet the cursor color through either a theme name/id, a RGB value or a HEX value;\n"
				+ "\tExamples:\n"
				+ "\t\t- Theme name/id: '" + C_GREEN_U + "vain -C 1" 
					+ C_OFF + "' sets the cursor color to the predefined cursor color of the theme with ID 1\n"
				+ "\t\t- RGB value: '" + C_GREEN_U + "vain -C \"85, 255, 0\"" 
					+ C_OFF + "' sets the cursor color to a bright green\n"
				+ "\t\t- HEX value: '" + C_GREEN_U + "vain -C \"#3ebfb3\"" 
					+ C_OFF + "' sets the cursor color to a teal tone\n"
				+ "\tDefault: Cursor color is defined by the theme you chose\n"
			},
			{"no-show-cursor",
				s("Usage of -c/--no-show-cursor:\n")
				+ "\tDisable the cursor while typing;\n"
				+ "\t\tExample: '" + C_GREEN_U + "vain --no-show-cursor" + C_OFF + "'\n"
				+ "\tDefault: off\n"
			},
			{"theme",
				s("Usage of -T/--theme:\n")
				+ "\tChange the theme to one of the predefined ones;\n"
				+ "\tThere are currently " 
					+ int_st(listener.get_themenames().size())
					+ " themes available:\n"
				+ print_themes()
				+ "\tBIG THANKS to https://github.com/st3w/neo for some "
					+ "theme colors which I shamelessly stole from their project\n"
				+ "\tExamples:\n"
				+ "\t\tBy name:  '" + C_GREEN_U + "vain --theme " 
					+ listener.get_themenames()[1] + C_OFF + "'\n"
				+ "\t\tBy index: '" + C_GREEN_U + "vain --theme 1" + C_OFF + "'\n"
				+ "\t\t\t(The index starts at 0, so 1 is the " 
					+ listener.get_themenames()[1] + " theme)\n"
				+ "\tDefault: Green theme with index 0\n"
			},
			{"background",
				s("Usage of -B/--background:\n")
				+ "\tSet the background color using HEX or RGB notation;\n"
				+ "\tThe background operates completely independent from the themes\n"
				+ "\t\tExample: '" + C_GREEN_U + "vain --background \"#685d59\""
					+ C_OFF + "' sets the background color to a brownish grey\n"
				+ "\tDefault: \"#000000\"\n"
			},
			{"spacing",
				s("Usage of --spacing:\n")
				+ "\tChange the amount of empty lines between individual blocks;\n"
				+ "\t\tExample: '" + C_GREEN_U + "vain --spacing 3" + C_OFF 
					+ "' produces three empty lines after each block\n"
				+ "\tDefault: " + int_st(spacing) + "\n"
			},
			{"until",
				s("Usage of --until:\n")
				+ "\tDefine until where the scroll file should be read;\n"
				+ "\tThis can be used to avoid long wait times or Out-Of-Memory "
					+ "situations when reading from very large files\n"
				+ "\tNote that vainglorious does NOT read until the end of the "
					+ "current block, it does a hard stop as soon as the given line is reached.\n"
				+ "\t\tExample: '" + C_GREEN_U + "vain --until 180 --scrollfile scroll.txt" + C_OFF
					+ "' reads until line 180 from the file \"scroll.txt\"\n"
				+ "\tDefault: The scrollfile is read until EOF\n"
			},
			{"forcedraw",
				s("Usage of --forcedraw:\n")
				+ "\tForce the program to redraw the whole screen every time an event happens;\n"
				+ "\tThis prevents artefacts of text where it doesn't belong in some cases.\n"
				+ "\t\tExample: '" + C_GREEN_U + "vain --forcedraw" + C_OFF "' enables force drawing.\n"
				+ "\tDefault: off.\n"
			},
			{"behaviour",
				s("Usage of -b/--movement-behaviour:\n")
				+ "\tSet if the text should be advanced by typing or "
					+ "if it should scroll automatically;\n"
				+ "\tTakes in either \"input\" or \"auto\" (in any capitalization)\n"
				+ "\t\tExample: '" + C_GREEN_U + "vain --movement-behaviour auto"
					+ C_OFF + "'\n"
				+ "\tDefault: input\n"
			},
			{"style",
				s("Usage of -s/--movement-style:\n")
				+ "\tChange what a unit is that is added to the text every event;\n"
				+ "\tCan be either LINE, WORD, CHARACTER or BLOCK\n"
				+ "\t(The flag -S/--movement-speed changes how many units are placed per event)\n"
				+ "\t\tExample: '" + C_GREEN_U + "vain --movement-style line"
					+ C_OFF + "' advances the text in lines\n"
				+ "\tDefault: WORD\n"
			},
			{"speed",
				s("Usage of -S/--movement-speed:\n")
				+ "\tChange how many units (see -s/--movement-style) are placed per event\n"
				+ "\tExamples:\n"
				+ "\t\t'" + C_GREEN_U + "vain -s line -S 4" 
					+ C_OFF + "' adds 4 lines per keypress\n"
				+ "\t\t'" + C_GREEN_U + "vain -s character -S 8 -b auto" 
					+ C_OFF + "' adds 8 characters per automatic event (see -d/--movement-delay)\n"
				+ "\tDefault: " + int_st(speed) + " (With -b and -s that gives: 1 word is advanced per keypress)\n"
			},
			{"delay",
				s("Usage of -d/--movement-delay:\n")
				+ "\tChange in which intervals events happen if -b is set to auto (in seconds)\n"
				+ "\t\tExample: '" + C_GREEN_U + "vain --movement-behaviour auto --movement-delay 0.2"
					+ C_OFF + "' makes the text advance every 0.2 seconds without requiring manual input\n"
				+ "\tDefault: " + int_st(auto_delay) + " seconds \n"
			},
			{"dry",
				s("Usage of --dry:\n")
				+ "\tDon't enter the ncurses environment, stop after argument processing;\n"
				+ "\t(For debug purposes only)\n"
			},
			{"help",
				s("Usage of -h/--help:\n")
				+ "\tShow this help text\n"
			}
		};
	public:
		void process(int argc, char* argv[]);
		void makepairs();
		 
		std::string get_file() { return file; }
		int get_read_until() { return read_until; }
		 
		int get_limit() { return limit; }
		int get_spacing() { return spacing; }
		bool get_forcedraw() { return forcedraw; }
		 
		int get_themeid() { return themeid; }
		/* Returns either default theme or custom theme */
		std::vector<Color> get_theme();
		bool get_show_cursor() { return show_cursor; }
		/* Returns curcol of theme_id when custom_cur is not set,
		 * custom_cur content if otherwise
		 */
		std::vector<unsigned char> get_curtheme();

		MovementBehaviour get_behaviour() { return behaviour; }
		ProgressStyle get_style() { return style; }
		int get_speed() { return speed; }
		float get_auto_delay() { return auto_delay; }
		 
		bool get_dry() { return dry; }
};

class File
{
	private:
		/* random offset; 
		 * Increases by one every time rblock() has been called
		 * Else, the same block would be chosen in each second
		 */
		int roff = 0; 
		std::vector<std::vector<std::string>> blocks;
	public:
		int crunch_file(Args my_args); // Parse scroll and fill blocks
		std::vector<std::string> rblock(); // Get a random block from the list
		 
		std::vector<std::vector<std::string>> get_blocks() { return blocks; }
};

class Render
{
	private:
		/* Driver grid that characters are put into
		 * and that is rendered every frame, offset by one
		 */
		struct Cell
		{
			char c;
			int col_id;
			Cell(char my_c, int my_col_id)
			{
				c = my_c;
				col_id = my_col_id;
			}
		};
		std::vector<std::vector<Cell>> grid;
		
		/* Only used when behaviour is AUTO */
		float seconds_to_input = 0;
		 
		/* Add a char where the color is handled
		 * automatically
		 */
		void add_colored_char(char c, std::vector<Color> col_data);
		int streak_left = 0;
		Color current_col;
		 
		/* "Low-Level" character adder
		 * Takes '\n' as a special argument
		 * to add a new line
		 */
		void add_char(char c, int c_pair);
		void render_grid();
		/* Delete the topmost line */
		void move_up();  
		
		void change_cur_color(std::vector<unsigned char> rgb);
		 
		/* Gets a random pair with the defined probabilities */
		Color random_col(std::vector<Color> );
		void add_line(std::string line, std::vector<Color> col_data);
		void cleardraw();
		 
		 
	public:
		int run(Args, File);
};

struct PairProb
{
	int pair_id; // The color pair id
	std::pair<int, int> app_length; // For how long it appears
	int prob; // Probability to start appearing
};

struct Color
{
	int id;
	int R, G, B;
	PairProb pair_prob;
};

// Holds information about all predefined themes
class DefTheme
{
	public:
		std::vector<std::string> get_themenames() {return themenames;}
		std::vector<std::string> get_colnames() {return colnames;}
		std::vector<Color> get_theme(int theme_id);
		std::vector<unsigned char> get_curcol(int theme_id);
	private:
		/* The input and display name for the default
		 * themes
		 * The sort order implies the id of each theme
		 * (e.g. the green theme has the id 0)
		 */
		std::vector<std::string> themenames =
		{
			"green",
			"gold",
			"yellow",
			"rainbow",
			"red",
			"blue",
			"cyan",
			"orange",
			"purple",
			"vaporwave",
			"gray"
		};
		/* General accepted names of colors,
		 * used for setting the background color,
		 * for example
		 */
		std::vector<std::string> colnames =
		{
			"black",
			"red",
			"green",
			"yellow",
			"blue",
			"magenta",
			"cyan",
			"white"
		};
		/* The default colors for the predefined themes
		 * The second layer is sorted by the theme ids
		 */
		std::vector<std::vector<Color>> themecols =
		{
			// These awesome colors are stolen from https://github.com/st3w/neo
			// GREEN
			{
				// COLORID, R,   G,   B,ColPair,length,probability
				{234,       71,  141, 83,  {1, {8,10}, 1} },
				{22,        149, 243, 161, {2, {8,10}, 1} },
				{28,        188, 596, 318, {3, {1,2}, 7} },
				{35,        188, 714, 397, {4, {1,3}, 8} },
				{78,        227, 925, 561, {5, {4,8}, 9} },
				{84,        271, 973, 667, {6, {3,5}, 12} },
				{159,       667, 1000, 941,{7, {3,6}, 7} }
			},
			// GOLD
			{
				{58, 839, 545, 216,   {1, {8, 10}, 2} },
				{94, 905, 694, 447,   {2, {8, 10}, 6} },
				{172, 945, 831, 635,  {3, {8, 10}, 4} },
				{178, 1000, 922, 565, {4, {8, 10}, 2} },
				{228, 1000, 953, 796, {5, {8, 10}, 2} },
				{230, 976, 976, 968,  {6, {8, 10}, 1} }
			},
			// YELLOW
			{
				// Default Xterm colors
				{100, -1,-1,-1, {1, {1, 9}, 2} },
				{142, -1,-1,-1, {2, {3, 7}, 2} },
				{184, -1,-1,-1, {3, {3, 7}, 4} },
				{226, -1,-1,-1, {4, {3, 7}, 5} },
				{227, -1,-1,-1, {5, {3, 7}, 3} },
				{229, -1,-1,-1, {6, {2, 4}, 4} },
				{230, -1,-1,-1, {7, {6, 12}, 3} }
			},
			// RAINBOW (cancer)
			{
				{196, -1,-1,-1, {1, {1, 6}, 1} },
				{208, -1,-1,-1, {2, {1, 6}, 1} },
				{226, -1,-1,-1, {3, {1, 6}, 1} },
				{46,  -1,-1,-1, {4, {1, 6}, 1} },
				{21,  -1,-1,-1, {5, {1, 6}, 1} },
				{93,  -1,-1,-1, {6, {1, 6}, 1} },
				{201, -1,-1,-1, {7, {1, 6}, 1} }
			},
			// RED
			{
				{234, -1,-1,-1, {1, {6, 8}, 1} },
				{52, -1,-1,-1,  {2, {3, 5}, 1} },
				{88, -1,-1,-1,  {3, {2, 4}, 3} },
				{124, -1,-1,-1, {4, {3, 5}, 6} },
				{160, -1,-1,-1, {5, {2, 3}, 5} },
				{196, -1,-1,-1, {6, {3, 4}, 7} },
				{197,255,56,59, {7, {4, 6}, 4} },
				{217, -1,-1,-1, {8, {2, 4}, 2} }
			},
			// BLUE
			{
				{234, -1,-1,-1, {1, {3, 6}, 1} },
				{17, -1,-1,-1,  {2, {3, 6}, 1} },
				{18, -1,-1,-1,  {3, {3, 8}, 1} },
				{19, -1,-1,-1,  {4, {3, 6}, 6} },
				{20, -1,-1,-1,  {5, {3, 6}, 6} },
				{21, -1,-1,-1,  {6, {3, 6}, 2} },
				{75, -1,-1,-1,  {7, {2, 5}, 4} },
				{159, -1,-1,-1, {8, {2, 5}, 1} }
			},
			// CYAN
			{
				{24, -1,-1,-1,  {1, {1, 1}, 1} },
				{25, -1,-1,-1,  {2, {1, 1}, 1} },
				{31, -1,-1,-1,  {3, {1, 1}, 1} },
				{32, -1,-1,-1,  {4, {1, 1}, 1} },
				{38, -1,-1,-1,  {5, {1, 1}, 1} },
				{45, -1,-1,-1,  {6, {1, 1}, 1} },
				{159, -1,-1,-1, {7, {1, 1}, 1} }
			},
			// ORANGE
			{
				{52, -1,-1,-1,  {1, {2,  5}, 1} },
				{94, -1,-1,-1,  {2, {6, 10}, 2} },
				{130, -1,-1,-1, {3, {6, 10}, 5} },
				{166, -1,-1,-1, {4, {6, 10}, 7} },
				{202, -1,-1,-1, {5, {6, 10}, 8} },
				{208, -1,-1,-1, {6, {6, 10}, 7} },
				{231, -1,-1,-1, {7, {2,  3}, 0} } // Simply too bright
			},
			// PURPLE
			{
				{60, -1,-1,-1,  {1, {1, 1}, 1} },
				{61, -1,-1,-1,  {2, {1, 1}, 1} },
				{62, -1,-1,-1,  {3, {1, 1}, 1} },
				{63, -1,-1,-1,  {4, {1, 1}, 1} },
				{69, -1,-1,-1,  {5, {1, 1}, 1} },
				{111, -1,-1,-1, {6, {1, 1}, 1} },
				{225, -1,-1,-1, {7, {1, 1}, 1} }
			},
			// VAPORWAVE
			{
				{53, -1,-1,-1,  {1, {6, 10}, 2} },
				{54, -1,-1,-1,  {2, {6, 10}, 2} },
				{55, -1,-1,-1,  {3, {6, 10}, 2} },
				{134, -1,-1,-1, {4, {6, 10}, 2} },
				{177, -1,-1,-1, {5, {6, 10}, 2} },
				{219, -1,-1,-1, {6, {6, 10}, 2} },
				{214, -1,-1,-1, {7, {6, 10}, 2} },
				{220, -1,-1,-1, {8, {6, 10}, 2} },
				{227, -1,-1,-1, {9, {6, 10}, 2} },
				{229, -1,-1,-1, {10, {6, 10}, 1} },
				{87, -1,-1,-1,  {11, {6, 10}, 1} },
				{123, -1,-1,-1, {12, {6, 10}, 1} },
				{159, -1,-1,-1, {13, {6, 10}, 1} },
				{195, -1,-1,-1, {14, {6, 10}, 1} },
				{231, -1,-1,-1, {15, {6, 10}, 1} },
			},
			// GRAY
			{
				{234, -1,-1,-1, {1, {6, 10}, 1} },
				{237, -1,-1,-1, {2, {6, 10}, 1} },
				{240, -1,-1,-1, {3, {6, 10}, 1} },
				{243, -1,-1,-1, {4, {6, 10}, 1} },
				{246, -1,-1,-1, {5, {6, 10}, 1} },
				{249, -1,-1,-1, {6, {6, 10}, 1} },
				{251, -1,-1,-1, {7, {6, 10}, 1} },
				{252, -1,-1,-1, {8, {6, 10}, 1} },
				{231, -1,-1,-1, {9, {6, 10}, 1} },
			}
		};
		/* Cursor colors corresponding to their schemes */
		std::vector<std::vector<unsigned char>> curcols =
		{
			// GREEN
			{68, 244, 167},
			// GOLD
			{188, 120, 12},
			// YELLOW
			{255, 255, 0},
			// RAINBOW
			{227, 67, 255},
			// RED
			{187, 4, 31},
			// BLUE
			{0, 0, 255},
			// CYAN
			{22, 158, 188},
			// ORANGE
			{180, 119, 20},
			// PURPLE
			{58, 39, 206},
			// VAPORWAVE
			{130, 97, 180},
			// GRAY
			{97, 102, 103}
		};
};

class Util
{
	private:
		// Convert a base 16 digit to it's base 10 equivalent
		int sixteen_to_ten(char ten_str);
	public:
		template <typename T>
		int veccmp(T to_comp, std::vector<T> vec)
		{
			for (long unsigned int i = 0; i<vec.size(); i++)
			{
				if (to_comp == vec[i])
					return i;
			}
			return ERROR;
		}
		/* I know, this makes an unordered_map a lil 
		 * stupid but the performance hit is minimal
		 * and I don't care enough to reengineer with
		 * an std::pair or something
		 */
		template <typename A, typename T>
		A valtokey(std::unordered_map<A, T> map, T val)
		{
			for (auto i = map.begin(); i != map.end(); i++)
			{
				if (i->second == val)
					return i->first;
			}
			return nullptr;
		}
		bool is_number(std::string string);
		std::vector<unsigned char> hextorgb(std::string hex);
		std::vector<std::string> split_at
			(std::string splitchar, std::string input);
		int random_int(int min, int max);
		std::string to_lower(std::string input);
};

#define INVERT(X)	X ? X = false : X = true;

void Args::process(int argc, char* argv[])
{
	for (int i = 1; i<argc; i++)
	{
		Util util;
		int match = util.veccmp<std::string>(std::string(argv[i]), switches);
		switch (match)
		{
			case 0: case 1: // -f, --scrollfile
				if (process_file(i, argc, argv) == ERROR)
				{
					std::cout << err_msgs.at("file");
					exit(1);
				}
				break;
			case 2: // --until
				if (process_until(i, argc, argv) == ERROR)
				{
					std::cout << err_msgs.at("until");
					exit(1);
				}
				break;
			case 3: case 4: // -l, --limit
				if (process_limit(i, argc, argv) == ERROR)
				{
					std::cout << err_msgs.at("limit");
					exit(1);
				}
				break;
			case 5: // --spacing
				if (process_spacing(i, argc, argv) == ERROR)
				{
					std::cout << err_msgs.at("spacing");
					exit(1);
				}
				break;
			case 6: // --forcedraw
				INVERT(forcedraw);
				break;
			case 7: case 8: // -T, --theme
				if (process_theme(i, argc, argv) == ERROR)
				{
					std::cout << err_msgs.at("theme");
					exit(1);
				}
				break;
			case 9: case 10: // -F, --colorfile
			{
				int ret = process_custom_theme(i, argc, argv);
				if (ret == -1)
				{
					std::cout << "The given colorfile could not be read"
						<< "Please check file permissions, ownership "
						<< "and existence." << std::endl;
					exit(1);
				}
				else if (ret == ERROR)
				{
					std::cout << err_msgs.at("colorfile");
					exit(1);
				}
				else if (ret != 0)
				{
					std::cout << "The given colorfile is invalid near "
						<< "line " C_GREEN_U << ret << C_OFF << "." << std::endl
						<< "\tHere is the info entry for colorfiles:" << std::endl
						<< err_msgs.at("colorfile");
					exit(1);
				}
				break;
			}
			case 11: case 12: // -B, --background
				if (process_background(i, argc, argv) == ERROR)
				{
					std::cout << err_msgs.at("background");
					exit(1);
				}
				break;
			case 13: case 14: // -C, --cursor
				switch(process_cursor(i, argc, argv))
				{
					case 0:
						break;
					case 1:
						std::cout << "The RED part of the hex code you provided is invalid.\n"
							<< "It has to be either the numbers 0-9 or one of the letters "
							<< "\"abcdef\" uppercase or lowercase."
							<< std::endl;
						exit(1);
						break;
					case 2:
						std::cout << "The GREEN part of the hex code you provided is invalid.\n"
							<< "It has to be either the numbers 0-9 or one of the letters "
							<< "\"abcdef\" uppercase or lowercase."
							<< std::endl;
						exit(1);
						break;
					case 3:
						std::cout << "The BLUE part of the hex code you provided is invalid.\n"
							<< "It has to be either the numbers 0-9 or one of the letters "
							<< "\"abcdef\" uppercase or lowercase."
							<< std::endl;
						exit(1);
						break;
					case 255:
						std::cout << "If you tried to enter an RGB value, you have to give three numbers between 0 and 256,\n"
							<< "separated by commata, enclosed in quotes, like this:\n" 
							<< C_GREEN_U << "\tvain -C \"0, 255, 0\"" << C_OFF << std::endl;
						exit(1);
						break;
					case 16: case ERROR:
						std::cout << err_msgs.at("cursor");
						exit(1);
						break;
				}
				break;
			case 15: case 16: // -c, --no-show-cursor
				INVERT(show_cursor);
				break;
			case 17: case 18: // -b, --movement-behaviour
				if (process_behaviour(i, argc, argv) == ERROR)
				{
					std::cout << err_msgs.at("behaviour") << std::endl;
					exit(1);
				}
				break;
			case 19: case 20: // -s, --movement-style
				if (process_style(i, argc, argv) == ERROR)
				{
					std::cout << err_msgs.at("style") << std::endl;
					exit(1);
				}
				break;
			case 21: case 22: // -S, --movement-speed
				if (process_speed(i, argc, argv) == ERROR)
				{
					std::cout << err_msgs.at("speed") << std::endl;
					exit(1);
				}
				break;
			case 23: case 24: // -d, --movement-delay
				if (process_auto_delay(i, argc, argv) == ERROR)
				{
					std::cout << err_msgs.at("delay") << std::endl;
					exit(1);
				}
				break;
			case 25: // --debug (UNUSED)
				break;
			case 26: // --dry
				INVERT(dry);
				break;
			case 27: case 28: // -h, --help
				show_help();
				exit(1);
				break;
			default:
				std::cout << "Invalid argument \"" << argv[i] << "\"!" << std::endl
					<< "\tDo '" << C_GREEN_U << "vain --help" << C_OFF 
						<< "' for info on how to use vainglorious!" << std::endl;
				exit(1);
				break;
		}
	}
}

void Args::makepairs()
{
	// Make background color
	init_color(0, bg_col[0], bg_col[1], bg_col[2]);
	DefTheme thm;
	for (int cols = 0; cols<get_theme().size(); cols++)
	{
		Color my_color = get_theme()[cols];
		/* If the given RGB value is invalid, init_color
		 * just doesn't change the color which enables
		 * setting colors of default pairs through just the
		 * same system as custom RGB colors in theme.h
		 */
		init_color(my_color.id, my_color.R, my_color.G, my_color.B);
		init_pair(my_color.pair_prob.pair_id, my_color.id, 0);
	}
}

int Args::process_file(int &i, int argc, char* argv[])
{
	i++;
	if (i > argc-1)
		return ERROR;
	file = argv[i];
	return 0;
}

int Args::process_limit(int &i, int argc, char* argv[])
{

	i++;
	if (i > argc-1)
		return ERROR;
	if (atoi(argv[i]) < 1)
		limit = 1;
	else
		limit = atoi(argv[i]);
	return 0;
}

int Args::process_theme(int &i, int argc, char* argv[])
{
	i++;
	if (i > argc-1)
		return ERROR;
	Util util;
	DefTheme thm;
	int match = util.veccmp<std::string>(util.to_lower(std::string(argv[i])), 
			thm.get_themenames());
	if (match != ERROR)
	{
		themeid = match;
		return 0;
	}
	if (util.is_number(std::string(argv[i])))
	{
		int num = atoi(argv[i]);
		if (num >= 0 && num < thm.get_themenames().size()) 
		{
			themeid = num;
			return 0;
		}
	}
	return ERROR;
}

int Args::process_custom_theme(int &i, int argc, char* argv[])
{
	// Get colorfile name
	i++;
	if (i > argc-1)
		return ERROR;
	std::string name = std::string(argv[i]);
	std::ifstream cfile(name);
	if (!cfile.is_open())
		return -1; // File is unknown
	
	// Set themeid to -1 to mark that the theem used is
	// not to be found in DefTheme objects
	themeid = -1;
	
	// Parse colorfile
	int lnum = 0;
	std::string line;
	while (getline(cfile, line))
	{
		
		// Discard line from a '%'(comment) sign on
		for (int i = 0; i<line.size(); i++)
		{
			if (line[i] == '%')
			{
				line = line.substr(0, i);
				break;
			}
		}
		 
		if (line.empty())
		{
			lnum++;
			continue;
		}
		 
		 
		Util util;
		std::vector<std::string> spl = util.split_at(",", line);
		bool hex = false;
		if (spl[0][0] == '#')
			hex = true;
		if (!hex && spl.size() < 3) // Can't contain RGB value
			return lnum+1;
		std::vector<unsigned char> rgbval;
		try
		{
			if (hex)
				rgbval = unify_color_input(spl[0]);
			else
				rgbval = unify_color_input(spl[0] + "," + spl[1] + "," + spl[2]);
		}
		catch (int e)
		{
			return lnum+1;
		}
		 
		// First line is background color
		if (lnum == 0)
		{
			bg_col = {int(rgbval[0]*NCFAC), int(rgbval[1]*NCFAC), int(rgbval[2]*NCFAC)};
			lnum++;
			continue;
		}
		
		// Determine min, max and probability
		int min = 1, max = 1, prob = 1;
		if (hex && spl.size() >= 3)
		{
			min = std::stoi(spl[1]);
			max = std::stoi(spl[2]);
			if (spl.size() > 4)
				prob = std::stoi(spl[3]);
		}
		else if (spl.size() >= 5)
		{
			min = std::stoi(spl[3]);
			max = std::stoi(spl[4]);
			if (spl.size() > 6)
				prob = std::stoi(spl[5]);
		}
		
		// Switch around min and max if they are mixed up
		if (min > max)
		{
			int orig_max = max;
			max = min;
			min = orig_max;
		}
		 
		// Construct final color
		Color this_col = 
			{lnum+35, 
				int(rgbval[0]*NCFAC), int(rgbval[1]*NCFAC), int(rgbval[2]*NCFAC),
				{lnum+1, {min, max}, prob}};
		custom_theme.push_back(this_col); // Push it to the theme
		lnum++;
	}
	cfile.close();
	return 0;
}

int Args::process_background(int &i, int argc, char* argv[])
{
	i++;
	if (i > argc-1)
		return ERROR;
	
	std::string input = std::string(argv[i]);
	std::vector<unsigned char> ret;
	try
	{
		ret = unify_color_input(input);
	}
	catch (int e)
	{
		return e;
	}
	bg_col[0] = ret[0]*NCFAC;
	bg_col[1] = ret[1]*NCFAC;
	bg_col[2] = ret[2]*NCFAC;
	return 0;
}

int Args::process_cursor(int &i, int argc, char* argv[])
{
	 
	i++;
	if (i > argc-1)
		return ERROR;
	std::string input = std::string(argv[i]);
	std::vector<unsigned char> ret;
	try
	{
		ret = unify_color_input(input); 
	}
	catch (int e)
	{
		return e; // Errors are handled by process_args itself
	}
	custom_cur = ret;
	return 0;
}

std::vector<unsigned char> Args::unify_color_input(std::string input)
{
	Util util;
	DefTheme thm;
	std::vector<std::string> tnames= thm.get_themenames();
	 
	/* Check if a theme name or id is provided */
	int match = 0;
	if (util.is_number(input))
		match = std::stoi(input);
	else
		match = util.veccmp<std::string>(input, tnames);
	 
	if (match != ERROR)
	{
		if (match < tnames.size() && match >= 0)
		{
			return thm.get_curcol(match); 
		}
	}
	 
	/* Check if a RGB value is provided (like "0,255,0") */
	std::vector<std::string> rgb = util.split_at(", ", input);
	if (rgb.size() == 3)
	{
		// TODO
		std::vector<unsigned char> rgbvals;
		for (int i = 0; i<3; i++)
		{
			int rgbval = 0;
			try
			{
				rgbval = std::stoi(rgb[i]);
			}
			catch (std::invalid_argument& e)
			{
				throw 255;
			}
			 
			if (rgbval >= 0 && rgbval <= 255)
				rgbvals.push_back(rgbval);
			else
				throw 255;
		}
		return rgbvals;
	}
	 
	/* Check if a HEX value is provided (like "#00ff00") */
	if (input.find('#') == 0)
	{
		if (input.size() == 7)
		{
			std::vector<unsigned char> curcol;
			try
			{
				curcol = util.hextorgb(input);
			}
			catch (int e)
			{
				// Invalidate input
				custom_cur = {};
				switch (e)
				{
					case 1:
						throw 1;
						break;
					case 2:
						throw 2;
						break;
					case 3:
						throw 3;
						break;
				}
				throw 16;
			}
			return curcol;
		}
	}
	throw ERROR;
}

int Args::process_until(int &i, int argc, char* argv[])
{
	i++;
	if (i > argc-1)
		return ERROR;
	Util util;
	if (!util.is_number(std::string(argv[i])))
		return ERROR;
	read_until = atoi(argv[i]);
	return 0;
}

int Args::process_spacing(int &i, int argc, char * argv[])
{
	i++;
	if (i > argc-1)
		return ERROR;
	Util util;
	if (!util.is_number(std::string(argv[i])))
		return ERROR;
	spacing = atoi(argv[i]);
	return 0;
}

std::vector<Color> Args::get_theme()
{
	std::vector<Color> ret;
	if (custom_theme.size() == 0)
	{
		DefTheme thm;
		ret = thm.get_theme(themeid);
	}
	else
	{
		ret = custom_theme;
	}
	return ret;
}

std::vector<unsigned char> Args::get_curtheme()
{
	DefTheme thm;
	if (custom_cur.size() == 0)
		return thm.get_curcol(themeid);
	else
		return custom_cur;
}


int Args::process_behaviour(int &i, int argc, char* argv[])
{
	i++;
	if (i > argc-1)
		return ERROR;
	Util util;
	int match = util.veccmp<std::string>(util.to_lower(std::string(argv[i])), {"input", "auto"});
	if (match == ERROR)
		return ERROR;
	switch(match)
	{
		case 0: behaviour = INPUT; break;
		case 1: behaviour = AUTO; break;
	}
	return 0;
}

int Args::process_style(int &i, int argc, char* argv[])
{
	i++;
	if (i > argc-1)
		return ERROR;
	Util util;
	int match = util.veccmp<std::string>(util.to_lower(std::string(argv[i])), {"line", "word", "character", "block"});
	if (match == ERROR)
		return ERROR;
	switch(match)
	{
		case 0: style = LINE; break;
		case 1: style = WORD; break;
		case 2: style = CHARACTER; break;
		case 3: style = BLOCK; break;
	}
	return 0;
}

int Args::process_speed(int &i, int argc, char* argv[])
{
	i++;
	if (i > argc-1)
		return ERROR;
	Util util;
	if (!util.is_number(std::string(argv[i])))
		return ERROR;
	int ipt = atoi(argv[i]);
	if (ipt < 0)
		return ERROR;
	speed = ipt;
	return 0;
}

int Args::process_auto_delay(int &i, int argc, char* argv[])
{
	i++;
	if (i > argc-1)
		return ERROR;
	Util util;
	if (!util.is_number(std::string(argv[i])))
		return ERROR;
	float ipt = float(atof(argv[i]));
	if (ipt < 0)
		return ERROR;
	auto_delay = ipt;
	return 0;
}

void Args::show_help()
{
	std::cout 
		<< "vainglorious - a feature-rich \"hacking\" simulator for your terminal\n"
		<< "Usage: vain [options...]"
		<< "\n"
		<< "\n"
		<< "OPTIONS\n"
		<< "\n"
		<< "Vainglorious features 14 distinct properties to edit\n"
		<< "that open possibilities like making your own text to type,\n"
		<< "custom themes, customizable scroll behaviours and much more\n"
		<< "Detailed showcase of every (relevant) flag:\n"
		<< "\n"
		<< C_RED_U << "Formatting 1337 CODE:\n" << C_OFF
		<< err_msgs.at("file")
		<< err_msgs.at("until")
		<< err_msgs.at("limit")
		<< err_msgs.at("spacing")
		<< err_msgs.at("forcedraw")
		<< "\n"
		<< C_RED_U << "Making it COLORFUL:\n" << C_OFF
		<< err_msgs.at("theme")
		<< err_msgs.at("colorfile")
		<< err_msgs.at("background")
		<< err_msgs.at("cursor")
		<< err_msgs.at("no-show-cursor")
		<< "\n"
		<< C_RED_U << "Changing the HEAT:\n" << C_OFF
		<< err_msgs.at("behaviour")
		<< err_msgs.at("style")
		<< err_msgs.at("speed")
		<< err_msgs.at("delay")
		<< "\n"
		<< C_RED_U << "Popping the HOOD:\n" << C_OFF
		<< err_msgs.at("dry")
		<< err_msgs.at("help")
		<< "\n"
		<< "Have fun using vainglorious! May your friends be frightened ;)!\n"
		<< "(Find this project under https://github.com/Dangertech/vainglorious)\n"
		<< "Written by Kjell Nagel <dangertech@e.email>\n"
		;
}

int File::crunch_file(Args my_args)
{
	std::ifstream scroll;
	scroll.open(my_args.get_file());
	if (!scroll.is_open())
		return ERROR;
	std::string cur_line;
	int lnum = 1;
	std::vector<std::string> cur_block;
	while (getline(scroll, cur_line))
	{
		if (my_args.get_read_until() != -1 && lnum > my_args.get_read_until())
			break;
		if (cur_line == "") // Block finished, push!
		{
			if (cur_block.size() > 0)
				blocks.push_back(cur_block);
			cur_block.clear();
		}
		else
		{
			cur_block.push_back(cur_line);
		}
		lnum++;
	}
	// Push the last block before EOF
	if (cur_block.size() > 0)
		blocks.push_back(cur_block);
	scroll.close();
	return 0;
}

std::vector<std::string> File::rblock()
{
	srand(time(0) + roff);
	int cho = rand()%blocks.size();
	roff++;
	return blocks[cho];
}

Args args;
File scrollfile;
Render render;

int main(int argc, char* argv[])
{
	// Process Arguments
	std::cout << "Processing Arguments..." << std::endl;
	args.process(argc, argv);
	 
	// Crunch through scrollfile
	std::cout << "Target Scroll File Is: " << args.get_file() << std::endl;
	std::cout << "Crunching through Scroll file...";
	if (scrollfile.crunch_file(args) == ERROR)
	{
		std::cout << "Error opening scroll! Please check file ownership!" << std::endl;
		return 1;
	}
	std::cout << "Done!" << std::endl;
	std::cout << "Total blocks found: " << scrollfile.get_blocks().size() << std::endl;
	 
	 
	// Check if dry run was specified
	if (args.get_dry())
	{
		std::cout << "Dry run, exiting!" << std::endl;
		return 5;
	}
	std::cout << "Initializing Display..." << std::endl;
	// initscr() starts here
	if (render.run(args, scrollfile) == 0)
	{
		std::cout << "Exiting gracefully!" << std::endl;
		return 0;
	}
	return ERR_UNKNOWN;
}

void Render::move_up()
{
	grid.erase(grid.begin());
}

void Render::add_char(char c, int c_pair)
{
	if (grid.size() == 0)
		grid.push_back(std::vector<Cell>()); // Failsafe
	
	if (c != '\n')
		grid[grid.size()-1].push_back(Cell(c, c_pair));
	else
	{
		grid.push_back(std::vector<Cell>());
	}
	/* Actually, through this, there is
	 * ALWAYS AN EMPTY NEW LINE at the end of the
	 * text when a newline is cast from add_line(), for example
	 */
}

void Render::change_cur_color(std::vector<unsigned char> rgb)
{
	printf("\e]12;#%.2x%.2x%.2x\a", rgb[0], rgb[1], rgb[2]);
}

Color Render::random_col(std::vector<Color> col_data)
{
	// Basically our seed without using the time
	std::random_device rd;
	std::mt19937 gen(rd());
	
	// Get weights
	std::vector<int> weights(col_data.size());
	// Fill weights with defined weights from probability
	for (int i = 0; i<col_data.size(); i++)
		weights[i] = col_data[i].pair_prob.prob;
	
	std::discrete_distribution<> dist(weights.begin(), weights.end());
	 
	/* dist(gen) returns a color index according to the weights
	 * The whole chosen color is returned
	 */
	return col_data[dist(gen)]; 
}

void Render::add_line(std::string line, std::vector<Color> col_data)
{
	if (grid.size())
		add_char('\n', 1);
	for (int i = 0; i<line.size(); i++)
	{
		add_colored_char(line[i], col_data);
	}
}

void Render::add_colored_char(char c, std::vector<Color> col_data)
{
	// No more colors of the same type, assign a
	// new color to hand out
	if (streak_left == 0)
	{
		current_col = random_col(col_data);
		// Get a random integer between second and first of app_length
		Util util;
		streak_left = util.random_int(current_col.pair_prob.app_length.first, 
				current_col.pair_prob.app_length.second);
	}
	add_char(c, current_col.pair_prob.pair_id);
	streak_left--;
}

void Render::render_grid()
{
	/* This is used to move the
	 * cursor to the position before the
	 * last newline character so that it really
	 * looks like the cursor typed the lines/characters
	 */
	int lastxpos = 0;
	 
	move(0, 0);
	for (int i = 0; i<grid.size(); i++)
	{
		for (int j = 0; j<grid[i].size(); j++)
		{
			if (getcurx(stdscr) > getmaxx(stdscr)-2)
				break; // Stop rendering if text is beyond terminal bounds
			attron(COLOR_PAIR(grid[i][j].col_id));
			printw("%c", grid[i][j].c);
			attroff(COLOR_PAIR(grid[i][j].col_id));
			lastxpos = getcurx(stdscr);
		}
		// If the next line is empty,
		// lastxpos isn't updated because
		// the loop doesn't even run
		if (grid[i].size() == 0)
			lastxpos = getcurx(stdscr);
		printw("\n");
	}
	// Prepare y pos for cursor
	int lastypos = grid.size()-1;
	move(lastypos, lastxpos); // move cursor
}

void Render::cleardraw()
{
	for (int y = 0; y<getmaxy(stdscr); y++)
	{
		move(y, 0);
		for (int x = 0; x<getmaxx(stdscr); x++)
		{
			printw(" ");
		}
	}
	move(0, 0);
}

int Render::run(Args my_args, File my_scroll)
{
	std::vector<Color> theme = my_args.get_theme();
	/* Set cursor color
	 * This has to be done before initscr() is called
	 */
	change_cur_color(my_args.get_curtheme());
	 
	initscr();
	noecho(); // Turn off printing of pressed character
	if (my_args.get_behaviour() == AUTO)
		nodelay(stdscr, true);
	start_color(); // Use Colors
	// Disable cursor in case of -c
	if (!my_args.get_show_cursor())
		curs_set(0);
	 
	// Init colors
	my_args.makepairs();
	/* Draw everything once to set the background everywhere
	 * bkgd() or wbkgd() alone leaves a column black at the right 
	 * side of my terminal for some reason
	 */
	cleardraw();
	 
	int ch;
	std::vector<std::string> myblock;
	// Lines into a block
	int lines = 0;
	// Characters into a line on a block
	int chars = 0;
	/* If to_space is 0, everything
	 * runs normally, lines of blocks
	 * get added; If it's not 0, an empty line
	 * is inserted instead and to_space is decreased
	 * by one
	 */
	int to_space = 0;
	/* To avoid spacing on the first block to appear */
	bool first_space = true;
	 
	while (1)
	{
		// Wait for continuation
		// (or don't because nodelay() is set if behaviour is AUTO
		ch = getch();
		if (ch == 4) // CTRL-D
			break;
		else if (ch == 12) // CTRL-L
		{
			cleardraw();
			render_grid();
		}
		if (my_args.get_behaviour() == AUTO)
		{
			bool break_outer = false;
			using namespace std::chrono;
			high_resolution_clock::time_point begin = 
					high_resolution_clock::now();
			high_resolution_clock::time_point now = 
					high_resolution_clock::now();
			while (duration_cast<duration<double>>(now-begin).count() 
					< my_args.get_auto_delay())
			{
				now = high_resolution_clock::now();
				ch = getch();
				if (ch == 4) // CTRL-D
				{
					break_outer = true;
					break;
				}
				else if (ch == 12) // CTRL-L
				{
					cleardraw();
					render_grid();
				}
			}
			if (break_outer)
				break;
		}
		 
		// Place new characters and render them
		// If there's something to space, enter a new line instead!
			/* Blocks are an exception:
			 * When enabled, the spacing is
			 * run the same input as the rest
			 * of the block to not interrupt the flow
			 */
		for (int times = 0; times < my_args.get_speed(); times++)
		{
			// Setup blocks
			
			/* If everything in the block has been used,
			 * set new block and reset blockpos
			 */
			if (lines >= myblock.size())
			{
				myblock = my_scroll.rblock();
				lines = 0;
				// "Query" the spacing
				if (first_space)
					first_space = false;
				else
					to_space = my_args.get_spacing();
			}
			if (to_space == 0 || my_args.get_style() == BLOCK)
			{
				switch(my_args.get_style())
				{
					case LINE:
						add_line(myblock[lines].c_str(), theme);
						lines++;
						break;
					case WORD:
						while (myblock[lines][chars] != ' ')
						{
							add_colored_char(myblock[lines][chars], theme);
							chars++;
							if (chars >= myblock[lines].size())
							{
								chars = 0;
								add_char('\n', 1);
								lines++;
								// Fill up to the next real character
								if (lines < myblock.size())
								{
									while (myblock[lines][chars] == '\t')
									{
										add_char(myblock[lines][chars], 1);
										chars++;
									}
								}
								// Ensure at least one input per line
								break;
							}
						}
						if (lines < myblock.size())
						{
							while(myblock[lines][chars] == ' ')
							{
								add_colored_char(myblock[lines][chars], theme);
								chars++;
							}
						}
						break;
					case CHARACTER:
						// Skip tabs (User doesn't have to press keys for them)
						while (myblock[lines][chars] == '\t')
						{
							add_char(myblock[lines][chars], 1); 
							chars++;
						}
						add_colored_char(myblock[lines][chars], theme);
						chars++;
						// Break new line
						if (chars >= myblock[lines].size())
						{
							chars = 0;
							add_char('\n', 1);
							lines++;
						}
						break;
					case BLOCK:
						// Do the spacing first
						while(to_space > 0)
						{
							add_char('\n', 1);
							to_space--;
						}
						for (int i = 0; i<myblock.size(); i++)
						{
							for (int j = 0; j<myblock[i].size(); j++)
							{
								add_colored_char(myblock[i][j], theme);
							}
							add_char('\n', 1);
						}
						// Move up
						int scrlimit = getmaxy(stdscr)-my_args.get_limit();
						while (grid.size() > scrlimit)
							move_up();
						// Overflow the lines so a new block is assigned next input
						lines = myblock.size()+1;
						break;
				}
			}
			else
				add_char('\n', 1);
			 
			// Start moving up when the text has advanced far enough
			int scrlimit = getmaxy(stdscr)-my_args.get_limit();
			if (scrlimit < 0)
				scrlimit = 0;
			if (grid.size() > scrlimit)
				move_up();
			 
			// to_space management
			 
			if (to_space > 0)
				to_space--;
		}
		
		// Clear the screen every time something happens
		if (my_args.get_forcedraw())
			cleardraw();
		render_grid(); // Render dat shit!
	}
	endwin();
	// Reset cursor color
	change_cur_color({255, 255, 255});
	return 0;
}

std::vector<Color> DefTheme::get_theme(int theme_id)
{
	if (theme_id < themecols.size())
		return themecols[theme_id];
	else
		return themecols[0];
}

std::vector<unsigned char> DefTheme::get_curcol(int theme_id)
{
	if (theme_id < curcols.size())
		return curcols[theme_id];
	else
		return curcols[0];
}

int Util::sixteen_to_ten(char ten_str)
{
	ten_str = tolower(ten_str);
	if(isalpha(ten_str))
	{
		if (ten_str < 103)
			return ten_str-87;
		else
			// That's more than an f and not a hex code
			return ERROR;
	}
	else
		return ten_str-48;
}

bool Util::is_number(std::string string)
{
	for (int i = 0; i<string.size(); i++)
	{
		if (!std::isdigit(string[i]))
		{
			if (string[i] != '.')
				return false;
		}
	}
	return true;
}

std::vector<unsigned char> Util::hextorgb(std::string hex)
{
	std::vector<unsigned char> ret;
	int red = sixteen_to_ten(hex[1])*16 + sixteen_to_ten(hex[2]);
	if (red >= 0 && red <= 255)
		ret.push_back(red);
	else
		throw 1;
	int green = sixteen_to_ten(hex[3])*16 + sixteen_to_ten(hex[4]);
	if (green >= 0 && green <= 255)
		ret.push_back(green);
	else
		throw 2;
	int blue = sixteen_to_ten(hex[5])*16 + sixteen_to_ten(hex[6]);
	if (blue >= 0 && blue <= 255)
		ret.push_back(blue);
	else
		throw 3;
	return ret;
}

std::vector<std::string> 
Util::split_at(std::string splitchar, std::string input)
{
	std::vector<std::string> ret;
	int pointer = 0;
	 
	std::string temp;
	while (1 == 1)
	{
		while (input[pointer] != splitchar[0])
		{
			if (pointer >= input.size())
			{
				if (temp.size())
					ret.push_back(temp);
				return ret;
			}
			temp += input[pointer];
			pointer++;
		}
		ret.push_back(temp);
		temp = "";
		int spoint = 0;
		while (splitchar[spoint] == input[pointer])
		{
			spoint++;
			pointer++;
		}
	}
}

int Util::random_int(int min, int max)
{
	// Seeder
	std::random_device rd;
	 
	std::mt19937 gen(rd());
	 
	std::uniform_int_distribution<int> dist(min, max);
	 
	return dist(gen);
}

std::string Util::to_lower(std::string input)
{
	std::string lower;
	for (int i = 0; i<input.size(); i++)
	{
		lower += std::tolower(input[i]);
	}
	return lower;
}

void Args::handle_tag(int &arg_pos, int argc, char * argv[])
{
	arg_pos++;
	tag = argv[arg_pos];
}

void Args::handle_dest(int &arg_pos, int argc, char * argv[])
{
	arg_pos++;
	set_dest = argv[arg_pos];
}

void Args::show_help()
{
	std::cout
		<< "Usage: userlog [OPTIONS] MESSAGE\n"
		<< "An easy-to-use logger for human beings\n"
		<< "\n"
		<< "OPTIONs:\n"
		<< "    --tag/-t TAG(s)     Puts the given tags in square brackets in front of your message\n"
		<< "    --help/-h           Shows this help text and then terminates the program\n"
		<< "    --dest/-d           Set your own destination for this log entry\n"
		<< "                            If the path doesn't fully exist, userlog will try to create it\n"
		<< "\n"
		<< "EXIT CODES:\n"
		<< "    0                   userlog only returns 0 if a message was written to the log file.\n"
		<< "    1                   This help text was shown\n"
		<< "    2                   The log destination couldn't be opened;\n"
		<< "                            Check if userlog has the sufficient privileges to write to it\n"
		<< "    3                   No message was given\n"
		<< "\n"    
		<< "You can choose the directory in which userlog puts the logs at compile time by changing\n"
		<< "the variable 'LOG_LOC' at the top of the Makefile and issuing 'sudo make install' again.\n"
		<< "The default is '/var/log/userlog/'\n"
		<< "\n"
		<< "Additional info and instructions can be found at: <https://github.com/Dangertech/userlog>\n"
		<< "Written by Kjell Nagel, student at STAMA, Bad Kreuznach, Germany\n"
	;
	exit(1);
}

void Args::process_args(int argc, char *argv[])
{
	for (int i = 1; i<argc; i++)
	{
		if (util.begmatch(argv[i], "--"))
		{
			int entry = util.veccmp<std::string>(std::string(argv[i]), lswitches);
			switch(entry)
			{
				case 0: // --tag
					handle_tag(i, argc, argv);
					break;
				case 1:
					show_help();
					break;
				case 2: // --dest
					handle_dest(i, argc, argv);
					break;
			}
		}
		else if (util.begmatch(argv[i], "-"))
		{
			int entry = util.veccmp<std::string>(std::string(argv[i]), sswitches);
			switch(entry)
			{
				case 0: // -t
					handle_tag(i, argc, argv);
					break;
				case 1:
					show_help();
					break;
				case 2: // -d
					handle_dest(i, argc, argv);
					break;
			}
		}
		else
		{
			/* Argument MUST be log content (at least right now) */
			if (message == "")
				message = argv[i];
			else
				std::cout << "userlog: Setting more than one message is not allowed;" << std::endl;
		}
	}
}

class Args
{
	private:
		std::string message;
		std::string tag;
		std::string set_dest;
		std::vector <std::string> lswitches =
		{
			"--tag",
			"--help",
			"--dest"
		};
		 
		std::vector <std::string> sswitches =
		{
			"-t",
			"-h",
			"-d"
		};
		 
		/* Argument handlers: Get attached arguments to argument and dispatch the
		 * functions that solve them; Increase the position by the arguments you
		 * processed
		 */
		void handle_tag(int &arg_pos, int argc, char * argv[]);
		void handle_dest(int &arg_pos, int argc, char * argv[]);
		void show_help();
	public:
		// Goes through all given arguments, called from main
		void process_args(int argc, char *argv[]);
		inline std::string get_message() { return message; };
		inline std::string get_tag() { return tag; };
		inline std::string get_set_dest() { return set_dest; };
};

std::string File::get_logdir(Time_data time)
{
	/* Take LOG_LOC as base */
	std::string my_loc = LOG_LOC;
	my_loc += "/" + std::to_string(time.get_component("year"));
	my_loc += "/" + std::to_string(time.get_component("month"));
	/* Gives something like:
	 * /var/log/userlog/2022/0/
	 * Log of the third of January 2022
	 * Final logfile name (3.log) should be appended by File::get_logname()
	 */
	return my_loc;
}

std::string File::get_logname(Time_data time)
{
	return std::to_string(time.get_component("mday")) + ".log";
}

std::string File::format(Args my_arg, Time_data my_time)
{
	std::string str;
	 
	// Time
	std::vector<std::string> time =
	{
		{std::to_string(my_time.get_component("hour"))},
		{std::to_string(my_time.get_component("minute"))},
		{std::to_string(my_time.get_component("second"))}
	};
	for (int i = 0; i<time.size(); i++)
	{
		if (time[i].size() < 2)
			time[i].insert(0, "0");
	}
	str += "<" + time[0] + ":" + time[1] + ":" + time[2] + ">";
	 
	// Tags
	if (my_arg.get_tag() != "")
		str += " [" + my_arg.get_tag() + "]";
	 
	str += ": ";
	 
	// Message
	str += my_arg.get_message();
	return str; 
}

int File::make_dirs(std::string dir)
{
	std::vector<std::string> split = util.split(dir, '/');
	std::string cur_path = "/" + split[1];
	mkdir(cur_path.c_str(), 0777);
	for (int i = 2; i<split.size(); i++)
	{
		/* Always try to make the directories, even if they exist
		 * because it doesn't change anything,
		 * mkdir() just silently fails
		 */
		cur_path += "/" + split[i];
		mkdir(cur_path.c_str(), 0777);
	}
	return ERROR;
}

int File::write_entry(Args my_arg)
{
	if (my_arg.get_message() == "")
		return ERR_NO_IPT;
	std::string location;
	if (my_arg.get_set_dest() == "")
		location = get_logdir(systime) + "/" + get_logname(systime);
	else
		location = my_arg.get_set_dest();
	/* Create needed directories */
	make_dirs(get_logdir(systime));
	/* Open File in append mode */
	std::ofstream logfile(location, std::ios_base::app);
	if (logfile.is_open())
	{
		/* Write! */
		logfile << format(my_arg, systime) << std::endl;
	}
	else
		return ERROR;
	logfile.close();
	return 0;
}

class File
{
	private:
		std::string get_logdir(Time_data time); // /var/log/userlog/2022/0
		std::string get_logname(Time_data time); // 27.log
		/* Format the stuff in the argument to the format in which they
		 * appear in the log
		 */
		std::string format(Args my_arg, Time_data my_time);
		/* Make as many directories as needed to 
		 * make the specified dir possible, e.g:
		 * make_dirs("/home/username/dir_one/dir_two/dir_three")
		 * -> Provided that dir_two and dir_three don't exist yet, create them
		 */
		int make_dirs(std::string dir);
	public:
		// Write the entry to a file
		int write_entry(Args my_arg);
};

int main(int argc, char *argv[])
{
	systime.set_current_time();
	args.process_args(argc, argv);
	int opout = file.write_entry(args); // Write to the log
	switch(opout)
	{
		case 0:
			return 0;
			break;
		case ERROR:
			if (args.get_set_dest() == "")
				std::cout << "userlog: Couldn't open log file! Please check the privileges of your userlog location: " << LOG_LOC << std::endl;
			else
				std::cout << "userlog: The set destination file is not writable! This file could not be accessed: " << args.get_set_dest() << std::endl;
			return 2;
		case ERR_NO_IPT:
			std::cout << "userlog: A message is required" << std::endl;
			return 3;
			break;
	}
	return 0;
}

void Time_data::set_current_time()
{
	time_t epoch = time(NULL);
	struct tm *s = localtime(&epoch);
	
	year = s->tm_year + 1900; // Gives year since 1900, so add those
	month = s->tm_mon;
	mday = s->tm_mday;
	hour = s->tm_hour;
	minute = s->tm_min;
	second = s->tm_sec;
}

int Time_data::get_component(std::string cname)
{
	std::vector<std::string> poss = {"year", "month", "mday", "hour", "minute", "second"};
	int val = util.veccmp<std::string>(cname, poss);
	 
	switch (val)
	{
		case 0:
			return year;
		case 1:
			return month;
		case 2:
			return mday;
		case 3:
			return hour;
		case 4: 
			return minute;
		case 5:
			return second;
		case ERROR:
			return ERROR;
	}
	return ERROR;
}


class Time_data
{
	private:
		int year;
		int month;
		int mday; // from 0 to 31
		int hour; 
		int minute;
		int second;
	public:
		void set_current_time();
		 
		int get_component(std::string component);
		/* Get the components of the time_data:
		 * "year", "month", "mday", "hour", "minute", "second"
		 */
} extern systime;

bool Util::begmatch(const char* to_comp, const char* against)
{
	if (strncmp(to_comp, against, strlen(against)) == 0)
		return true;
	return false;
}

std::vector<std::string> Util::split(std::string input, char breaker, 
		bool exclude_breaker /*= true*//*, bool right_breaker /*= false*/)
{
	std::vector<std::string> splitvec;
	std::vector<int> marks = {-1}; // Pos 0 is the first breaker
	/* Get marks on where to break up */
	for (long unsigned int i = 0; i<input.size()-1; i++)
	{
		if (input[i] == breaker)
			marks.push_back(i); 
	}
	marks.push_back(input.size());
	/* Put the stuff along the marks into the splitvec */
	for (long unsigned int i = 1; i<marks.size(); i++)
	{
		std::string part;
		for (long unsigned int j = marks[i-1]+exclude_breaker; j<marks[i]; j++)
		{
			part += input[j];
		}
		splitvec.push_back(part);
	}
	return splitvec;
}

class Util
{
	public:
		/* Output the location of a variable in a vector of variables
		 * Return ERROR if it isn't contained within
		 */
		template <typename T>
		int veccmp(T to_comp, std::vector<T> vec) 
		{
			for (long unsigned int i = 0; i<vec.size(); i++)
			{
				if (to_comp == vec[i])
					return i;
			}
			return ERROR;
		}

		std::vector<std::string> split(std::string input, char breaker, 
				bool exclude_breaker = true/*, bool right_breaker = false*/);
		 
		// Match against the beginning of a string: Is against at the beginning of to_comp?
		bool begmatch(const char* to_comp, const char* against);
} extern util;

int main()
{
	//Initialize ncurses
	initscr();
	// Standard attributes
	noecho();
	keypad(stdscr, TRUE);
	start_color();
	curs_set(0);
	 
	// Initialize Color pairs
	init_pair(1, COLOR_GREEN, COLOR_BLACK);
	init_pair(2, COLOR_RED, COLOR_BLACK);
	init_pair(3, COLOR_BLUE, COLOR_BLACK);
	init_pair(4, COLOR_YELLOW, COLOR_BLACK);
	// Error color pair
	init_pair(66, COLOR_WHITE, COLOR_RED);
	 
	// Get the initial screen size
	max_x = getmaxx(stdscr);
	max_y = getmaxy(stdscr);
	
	
	///////////////// Make a "New Game" Menu
	
	if (start_menu() == 1)
	{
		endwin();
		return 0;
	}
	
	if (dbg == true)
		mvprintw(max_y - 3, max_x - 20, "starting_player: %d", starting_player);
	
	 
	 
	///////////////// Main game loop
	 
	bool restart = true;
	while (restart == true) // Game Loop overspanning all games in this session
	{
		////// Set up game
		 
		ch = 0; // Clear ch before next use;
		current_player = starting_player;
		turn = 0;
		 
		// Update the screen size every restart
		max_x = getmaxx(stdscr);
		max_y = getmaxy(stdscr);
		grid.clear();
		 
		// Push all Pixels into the grid vector
		for (int y = 0; y < grid_size_y; y++)
		{
			grid.push_back(std::vector<Pixel>());
			for (int x = 0; x < grid_size_x; x++)
			{
				Pixel pixel;
				pixel.pos_y = y;
				pixel.pos_x = x;
				grid[y].push_back(pixel);
			}
		}
		// Select the first pixel so that the player can easily see that there is some kind of cursor he can move
		set_grid_sel(0, 0, true);
		y_index = 0, x_index = 0; // Also reset indices for the selection of human_turn()
		
		///// Actual game
		 
		render_grid(); // Render the field once to show the grid before the user presses something
		 
		while (1) // Loop while the main game is running
		{
			if (dbg == false && max_y > grid_size_y * 2 + 13)
				help_text(max_y - 8, 2);
			if (current_player == 1 || gamemode == 1)
			{
				// Let the human make a turn 
				if (human_turn() == 1) // Returns 1 if the user presses 'q' to quit
				{
					endwin();
					return 0;
				}
				 
				if (gamemode == 1) // Advance in multiplayer
				{
					if (current_player == 1)
						current_player = 2;
					else if (current_player == 2)
						current_player = 1;
					if (current_player == starting_player)
						turn++;
				}
				else // Let the computer make a turn in singleplayer
					current_player = 2;
			}
			
			 
			// Check if a player has won
			
			int win = detect_win();
			if (win == 0)
			{
				if (dbg == true)
					mvprintw(max_y -8, 2, "No player has won");
			}
			else if (win == -1)
			{
				if (dbg == true)
					mvprintw(max_y -8, 2, "The field is full! The game has finished with a tie!");
				current_player = -1;
				break;
			}
			else
			{
				if (dbg == true)
					mvprintw(max_y - 8, 2, "Player %d has won!", win);
				current_player = win;
				break;
			}
			 
			if (gamemode == 0 && current_player == 2) // Singleplayer logic
			{
				computer_turn();
				win = detect_win();
				current_player = 1; // Set current player to the real one again
				turn++;
				if (win == 2)
				{
					if (dbg == true)
						mvprintw(max_y - 8, 2, "The computer has won!");
					current_player = win;
					break;
				}
				else if (win == -1)
				{
					if (dbg == true)
						mvprintw(max_y - 8, 2, "The field is full! The game has finished with a tie!");
					current_player = -1;
					break;
				}
			} 
			 
			render_grid();
		}
		 
		render_grid();
		int win_menu_state = win_menu();
		if (win_menu_state == 0)
		{
			restart = false;
		}
	}
	endwin();
	return 0;
}

// Let a human make a turn
int human_turn()
{
	bool is_done = false;
	do // Loop to make sure the player selects a valid pixel
	{
		// Clear ch so that ch in't 10 and the while loop gets skipped
		ch = 0;
		 
		// Player selects Pixel to occupy
		while (ch != 10 && ch != ' ') // Loop until 'Enter' or Space is pressed
		{
			// Grab input
			ch = getch();
			if (dbg == true)
				mvprintw(max_y-3, 2, "%d", ch);
			if (ch == 113) // If 'q' is pressed, quit immediately
			{
				return 1;
			}
			 
			// Process arrow key input
			switch(ch)
			{
				case KEY_DOWN: case 'j': case 's':
					y_index++; break;
				case KEY_UP: case 'k': case 'w':
					y_index--; break;
				case KEY_LEFT: case 'h': case 'a':
					x_index--; break;
				case KEY_RIGHT: case 'l': case 'd':
					x_index++; break;
			}
			
			// Deselect all pixels
			for (int i = 0; i < grid.size(); i++)
			{
				for (int j = 0; j < grid[i].size(); j++)
				{
					set_grid_sel(i, j, false);
				}
			}
			 
			// Check if indices should reset to another position because they got out of bounds
			if (y_index < 0)
				y_index = 0; 
			if (y_index > grid.size()-1) 
				y_index = grid.size() -1; 
			if (x_index < 0) 
				x_index = 0;
			if (x_index > grid[0].size()-1) 
				x_index = grid[0].size() -1; 
			
			if (dbg == true)
				mvprintw(max_y -5, 2, "y_index: %d, x_index: %d, grid.size(): %d, grid[0].size: %d", y_index, x_index, grid.size(), grid[0].size());
			// Select the Pixel with the current index
			set_grid_sel(y_index, x_index, true);
			// Print the details of the currently selected pixel
			if (dbg == true)
				grid[y_index][x_index].print_details(max_y-4, 2);
			// Render it!
			render_grid();
		}
		 
		// Check if that pixel is unoccupied
		if (get_grid_val(y_index, x_index) == 0)
		{
			// Occupy the pixel with the current_player after the user presses 'Enter'
			set_grid_val(y_index, x_index, current_player);
			is_done = true;
		}
		else
			// The loop continues until the player tries to occupy a valid pixel
			is_done = false;
		render_grid();
	} while (is_done == false);
	return 0;
}

// Check if a player has won
int detect_win()
{
	int x_parse = 0, y_parse = 0;
	int player_checked;
	bool vert_won = false, hor_won = false, dia_right_won = false, dia_left_won = false;
	//weak_pixels.clear();
	// Repeat until the end of the grid is reached
	while (y_parse < grid_size_y && x_parse < grid_size_x)
	{
		///// Get a pixel to start counting from on
		
		while (get_grid_val(y_parse, x_parse) == 0)
		{
			if (y_parse == grid_size_y -1 && x_parse == grid_size_x -1)
				break;
			if (x_parse == grid_size_x-1)
			{
				x_parse = 0;
				y_parse++;
			}
			else
			{
				x_parse++;
			}
		}
		player_checked = get_grid_val(y_parse, x_parse);
		int ref_pixel_y = y_parse, ref_pixel_x = x_parse;
		 
		///// Check for wins vertically
		
		// Set vert_won to true and see if it passes all tests and stays true
		vert_won = true;
		for (int i=0; i<pixels_needed; i++)
		{
			// Variable for weak pixel detection:
			// Check if the streak can be skipped because it is impossible to win starting here
			if (ref_pixel_y <= grid_size_y - pixels_needed)
			{
				if (get_grid_val(ref_pixel_y + i, ref_pixel_x) != player_checked)
				{
					// If a pixel downwards that is in range of pixels_needed doesn't have the value of the current player, break the statement immediately and set vert_won to false
					vert_won = false;
					break;
				}
				 
			}
			else
			{
				vert_won = false;
			}
		}
		// If vert_won is still true, player_checked must have won!
		if (vert_won == true)
			return player_checked;
		 
		 
		///// Check for wins horizontally
		
		hor_won = true;
		for (int i=0; i<pixels_needed; i++)
		{
			if (ref_pixel_x <= grid_size_x - pixels_needed)
			{
				if (get_grid_val(ref_pixel_y, ref_pixel_x+i) != player_checked)
				{
					hor_won = false;
					break;
				}
				 
			}
			else
				hor_won = false;
		}
		 
		if (hor_won == true)
			return player_checked;
		 
		 
		///// Check for wins diagonally to the right
		 
		dia_right_won = true;
		for (int i=0; i<pixels_needed; i++)
		{
			if (ref_pixel_x <= grid_size_x - pixels_needed && ref_pixel_y <= grid_size_y - pixels_needed)
			{
				if (get_grid_val(ref_pixel_y+i, ref_pixel_x+i) != player_checked)
				{
					dia_right_won = false;
					break;
				}
			}
			else
				dia_right_won = false;
			 
		}
		 
		if (dia_right_won == true)
			return player_checked;
		 
		 
		///// Check for wins diagonally to the left
		 
		dia_left_won = true;
		for (int i=0; i<pixels_needed; i++)
		{
			if (ref_pixel_x <= grid_size_x + pixels_needed && ref_pixel_y <= grid_size_y - pixels_needed)
			{
				if (get_grid_val(ref_pixel_y+i, ref_pixel_x-i) != player_checked)
				{
					dia_left_won = false;
					break;
				}
			}
			else
				dia_left_won = false;
			 
		}
		 
		if (dia_left_won == true)
			return player_checked;
		 
		// Increase the parse to not get stuck on the same pixel again
		if (x_parse >= grid_size_x-1)
		{
			x_parse = 0;
			y_parse++;
		}
		else
		{
			x_parse++;
		}
		
	}
	 
	// Check if all spaces on the field are full
	// Just reuse x_ and y_parse
	// NOT WORKING AT THE MOMENT, Game just hangs if all fields are full because it tries to calculate an impossible computer turn
	x_parse = 0, y_parse = 0;
	while (1)
	{
		// If y_parse has just grown over the grid size, return -1;
		if (y_parse == grid_size_y)
			return -1;
		 
		if (get_grid_val(y_parse, x_parse) == 0)
			break;
		 
		// Continue parsing
		if (x_parse == grid_size_x - 1)
		{
			x_parse = 0;
			y_parse++;
		}
		else
			x_parse++;
	}
	 
	// Return 0 if no one has won
	if (vert_won == false && hor_won == false && dia_right_won == false && dia_left_won == false)
		return 0;
	// Error return value so that the compiler doesn't complain
	return -2;
}


// Variables used by computer_turn()
int rand_y, rand_x;
int place_y, place_x;
int origin_y, origin_x;
int expansion, prev_expansion;

// Print all entries in weak_pixels below each other
void print_weak_pixels(int y_pos, int x_pos)
{
	// Clear the lines to not show any outdated info
	for (int i = 0; i<8; i++)
	{
		mvprintw(y_pos + i, x_pos, "\n");
	}
	for (int i = 0; i < weak_pixels.size(); i++)
	{
		mvprintw(y_pos + i, x_pos, "Entry %d: Y: %d, X: %d", i, weak_pixels[i][0], weak_pixels[i][1]);
	}
}

// Function to push back X and Y locations to weak_pixels in a single statement
void push_to_weak(int y_val, int x_val)
{
	if (get_grid_val(y_val, x_val) == 0)
	{
		weak_pixels.push_back(std::vector<int>());
		weak_pixels[weak_pixels.size() - 1].push_back(y_val);
		weak_pixels[weak_pixels.size() - 1].push_back(x_val);
	}
}
 
// Get a random spot to start placing pixels
void get_start_spot()
{
	// Seed rand()
	srand(time(0));
	do
	{
		// Check if rand() can generate without crashing
		if( pixels_needed < grid.size())
			// Choose a location that has a lot of free space around it
			rand_y = rand() % (grid.size() - pixels_needed) + 1;
		else
			// If not, just don't care about placement in free space
			rand_y = rand() % (grid.size());
		 
		if( pixels_needed < grid[0].size())
			rand_x = rand() % (grid[0].size() - pixels_needed) + 1;
		else
			rand_x = rand() % (grid[0].size());
	}
	while(get_grid_val(rand_y, rand_x) != 0);
	 
	place_y = rand_y, place_x = rand_x;
	origin_y = rand_y, origin_x = rand_x;
	// Place the pixel
	set_grid_val(place_y, place_x, 2);
}

void computer_turn()
{
	// Get a random spot on the first turn
	if(turn == 0)
	{
		get_start_spot();
		// ALWAYS return after invoking get_start_spot() to prevent placing a pixel
		return;
	}
	
	 
	///// EXPANSION OF A PIXEL LINE
	 
	prev_expansion = expansion;
	expansion = 0;
	// Check to where the pixel line can be expanded
	// And return an integer value
	// Keep track of iterations, in every iteration the computer checks a line in one direction
	int iteration = 0;
	while (expansion == 0)
	{
		// Set two parsers to the origin point
		int parse_x = origin_x, parse_y = origin_y;
		// Checker variable that only remains false if the loop was successful and a pixel can be placed in that direction
		bool move_on = false;
		int loop = 0;
		for (loop = 0; loop < pixels_needed; loop++)
		{
			// Avoid Segfault
			if (parse_y < grid.size() && parse_x < grid[0].size())
			{
				// If a pixel is occupied by the enemy player, move on
				if (get_grid_val(parse_y, parse_x) == 1)
				{
					move_on = true;
				}
			}
			 
			// Check expansions based on the current iteration
			switch(iteration)
			{
				case 0:
					parse_x++;
					break;
				case 1:
					parse_x--;
					break;
				case 2:
					parse_y++;
					break;
				case 3:
					parse_y--;
					break;
				case 4:
					parse_x++; parse_y++;
					break;
				case 5: 
					parse_x--; parse_y++;
					break;
			}
		}
		 
		// If move_on is still false, this expansion will be successful
		if (move_on == false)
		{
			// Set expansion to the corresponding iteration value
			switch(iteration)
			{
				case 0:
					expansion = 1;
					break;
				case 1:
					expansion = -1;
					break;
				case 2:
					expansion = 2;
					break;
				case 3:
					expansion = -2;
					break;
				case 4:
					expansion = 3;
					break;
				case 5:
					expansion = -3;
					break;
			}
		}
		// Increase iteration
		iteration++; 
		// If the Iteration exceeds the limit, there is no possible expansion; Find a new one
		if (iteration > 5)
		{
			refresh();
			get_start_spot();
			break;
			return;
		}
	}
	
	///// DETECTION OF DANGEROUS (WEAK) PIXELS OF THE OTHER PARTY
	weak_pixels.clear();
	int y_parse = 0, x_parse = 0;
	while (y_parse < grid_size_y && x_parse < grid_size_x)
	{
		// Find a pixel to start with
		while (get_grid_val(y_parse, x_parse) != 1)
		{
			if (y_parse == grid_size_y - 1 && x_parse == grid_size_x - 1)
				break;
			if (x_parse == grid_size_x - 1)
			{
				x_parse = 0;
				y_parse++;
			}
			else
				x_parse++;
		}
		 
		// Repeat this 4 times for 4 checks
		for (int i = 0; i < 4; i++)
		{
			int iter = 0;
			while (1)
			{
				// Get the check direction to perform in this loop
				// The switch has to be calculated every while iteration because iter changes each time
				int op_y, op_x;
				switch (i)
				{
					// Vertical Check
					case 0: op_y = y_parse + iter, op_x = x_parse; break;
					// Horizontal Check
					case 1: op_y = y_parse, op_x = x_parse + iter; break;
					// Diagonal right
					case 2: op_y = y_parse + iter, op_x = x_parse + iter; break;
					// Diagonal left
					case 3: op_y = y_parse + iter, op_x = x_parse - iter; break;
				}
				 
				// Check according to the operations set
				if (op_y >= grid_size_y || op_x >= grid_size_x)
				{
					// If the opponents pixel line is running towards the end of the grid, block the opposite side
					if (iter == pixels_needed - 1)
					{
						int neg_y = y_parse, neg_x = x_parse;
						switch (i)
						{
							case 0: neg_y--; break;
							case 1: neg_x--; break;
							case 2: neg_y--, neg_x--; break;
							case 3: neg_y--, neg_x++; break;
						}
						push_to_weak(neg_y, neg_x);
					}
					break;
				}
				// If you find a pixel that is unoccupied by Player 1
				if (get_grid_val(op_y, op_x) != 1)
				{
					// Check if you already crossed pixels_needed - 1 pixels and if the value of this pixel is empty
					if (iter == pixels_needed - 1)
					{
						// Push the pixel into weak
						push_to_weak(op_y, op_x);
						// Also push the pixel at the other side into weak
						int neg_y = y_parse, neg_x = x_parse;
						switch (i)
						{
							case 0: neg_y--; break;
							case 1: neg_x--; break;
							case 2: neg_y--, neg_x--; break;
							case 3: neg_y--, neg_x++; break;
						}
						push_to_weak(neg_y, neg_x);
					}
					break;
				}
				 
				// Increase iteration
				iter++;
			}
		}
		 
		// Continue parser to not get stuck on the same pixel again
		if (x_parse >= grid_size_x-1)
		{
			x_parse = 0;
			y_parse++;
		}
		else
		{
			x_parse++;
		}
	}
	 
	//print_weak_pixels(20,2);
	if (weak_pixels.size() == 0)
	{
		// If you expanded in that direction earlier, continue
		if (expansion == prev_expansion)
		{
			switch(expansion)
			{
				case 1:
					place_y = place_y, place_x++;
					break;
				case -1:
					place_y = place_y, place_x--;
					break;
				case 2:
					place_y++, place_x = place_x;
					break;
				case -2:
					place_y--, place_x = place_x;
					break;
				// Diagonal expansions only work downwards currently
				case 3:
					place_y++, place_x++;
					break;
				case -3:
					place_y++, place_x--;
					break;
				// Failsafe; The game has to continue in case of a human error!
				default:
					get_start_spot();
					return;
					break;
			}
		}
		// If not, move back to origin and go on from there
		else
		{
			switch(expansion)
			{
				case 1: 
					place_y = origin_y, place_x = origin_x + 1;
					break;
				case -1:
					place_y = origin_y, place_x = origin_x - 1;
					break;
				case 2:
					place_y = origin_y + 1, place_x = origin_x;
					break;
				case -2:
					place_y = origin_y - 1, place_x = origin_x;
					break;
				case 3:
					place_y = origin_y + 1, place_x = origin_x + 1;
					break;
				case -3:
					place_y = origin_y + 1, place_x = origin_x - 1;
					break;
				default:
					get_start_spot();
					return;
					break;
			}
		}
	}
	else
	{
		// Place the pixel on the weak pixel
		place_y = weak_pixels[0][0], place_x = weak_pixels[0][1];
	}
	 
	 
	//mvprintw(max_y - 12, 2, "expansion: %d, prev_expansion: %d, place_y: %d, place_x: %d", expansion, prev_expansion, place_y, place_x); 
	// Try to continue a pixel line
	if (place_y < grid.size() && place_x < grid[0].size())
	{
		if (get_grid_val(place_y, place_x) == 0)
			set_grid_val(place_y, place_x, 2);
		else
			get_start_spot();
	}
	else
		get_start_spot();
}

// Create a struct that holds option properties
struct menu_options
{
	std::string description;
	// Int if the option should have a value
	int display_value;
	// Text if the option should have different strings of text
	std::vector < std::string > display_text;
	int text_loc; // Pointer to the current entry to be displayed
	bool error;
};
 
// Construct a vector with the options
std::vector <menu_options> menu_container = 
{ 
	{"Rows", grid_size_y,{}, 0, false}, 
	{"Columns", grid_size_x, {}, 0,  false}, 
	{"Pixels needed to win", pixels_needed, {}, 0, false}, 
	{"Gamemode", 0, {"Singleplayer", "Multiplayer"}, 0, false },
	{"Player 1's Color", 0, {"Green", "Red", "Blue", "Yellow"}, player_one_color - 1, false }, 
	{"Player 1's Icon", 0, {"X", "O", "+", "-", "~", "@", "$", "#", "%"}, 0, false },
	{"Player 2's Color", 0, {"Green", "Red", "Blue", "Yellow"}, player_two_color - 1, false },
	{"Player 2's Icon", 0, {"X", "O", "+", "-", "~", "@", "$", "#", "%"}, 1, false },
	{"Starting Player", 0, {"You", "Opponent"}, starting_player, false}
};

// Function to render the menu later on with colors and characters
// matching the ones set by the player(s)
void xoxoprint(int line, std::string xoxo_str)
{
	int start_x = (max_x/2) - (xoxo_str.length() / 2);
	move(line, start_x);
	for (int i = 0; i<xoxo_str.length(); i++)
	{
		int temp_p_one_col = menu_container[4].text_loc + 1;
		int temp_p_two_col = menu_container[6].text_loc + 1;
		if (xoxo_str[i] == 'X')
		{
			// Print player_one's color and character
			attron(COLOR_PAIR(temp_p_one_col));
			addch(menu_container[5].display_text[menu_container[5].text_loc].at(0));
			attroff(COLOR_PAIR(temp_p_two_col));
		}
		else if (xoxo_str[i] == 'O')
		{
			// Print player_two's color and character
			attron(COLOR_PAIR(temp_p_two_col));
			addch(menu_container[7].display_text[menu_container[7].text_loc].at(0));
			attroff(COLOR_PAIR(temp_p_two_col));
		}
		else
		{
			// Print the remaining characters in the color
			// of the starting player
			if (menu_container[8].text_loc == 0)
				attron(COLOR_PAIR(temp_p_one_col));
			else if (menu_container[8].text_loc == 1)
				attron(COLOR_PAIR(temp_p_two_col));
			addch(xoxo_str[i]);
			attroff(COLOR_PAIR(temp_p_one_col));
			attroff(COLOR_PAIR(temp_p_two_col));
		}
	}
}

// Make a 'New game' menu
int start_menu() 
{
	// Create a window that the menu will be displayed on
	WINDOW *menu_win;
	
	
	int window_rows = menu_container.size() + 4, window_columns = 50;
	int x_origin = (max_x / 2) - ( window_columns / 2), y_origin = 13;
	int y_borders = 2; // Space to be left out before the first entry gets rendered
	int dis_val_start = window_columns - 16; // At which column to start rendering the entries
	int selected_entry = 0;
	menu_win = newwin( window_rows, window_columns, y_origin, x_origin); 
	//Draw everything until the user confirms with 'Enter'
	while (ch != 10 && ch != ' ')
	{
		switch (ch)
		{
			case KEY_UP: case 'k': case 'w':
				if (selected_entry > 0)
					selected_entry--;
			break;
			case KEY_DOWN: case 'j': case 's':
				if (selected_entry < menu_container.size()-1)
					selected_entry++;
			break;
			case KEY_LEFT: case 'h': case 'a':
				// If there is no text to be displayed, decrease the value of the int
				if (menu_container[selected_entry].display_text.size() == 0)
					menu_container[selected_entry].display_value--;
				// else, decrease the pointer to the current text entry
				else
				{
					menu_container[selected_entry].text_loc--;
					// Wrap around
					if (menu_container[selected_entry].text_loc < 0)
						menu_container[selected_entry].text_loc = menu_container[selected_entry].display_text.size() - 1;
				}
			break;
			case KEY_RIGHT: case 'l': case 'd':
				if (menu_container[selected_entry].display_text.size() == 0)
					menu_container[selected_entry].display_value++;
				else
				{
					menu_container[selected_entry].text_loc++;
					if (menu_container[selected_entry].text_loc == menu_container[selected_entry].display_text.size())
						menu_container[selected_entry].text_loc = 0;
				}
			break;
			case 'q':
				return 1;
			break;
		}
		 
		 
		 
		 
		///// ERROR HANDLING
		 
		// Make a vector that holds possible error messages
		std::vector <std::string> error_msgs;
		error_msgs.clear();
		// Push errors back into the error vector
		// 
		// Rows and columns
		for (int i = 0; i < 2; i++)
		{
			  
			int val = menu_container[i].display_value;
			// I know, this is pretty bad code but it's just a little easter egg
			if (val < 2)
			{
				error_msgs.push_back("Sizes smaller than two are not supported!");
				error_msgs.push_back("You may experience crashes and unexpected behaviour!");
			}
			else if (val > 30 && val < 120)
			{
				error_msgs.push_back("You need a sufficiently large screen to properly display high grid sizes!");
				error_msgs.push_back("You may experience unexpected behaviour!");
			}
			else if (val > 120 && val < 235)
				error_msgs.push_back("I don't think there's a screen that large...");
			else if (val > 235 && val < 512)
				error_msgs.push_back("Ok, you're bored, right?");
			else if (val > 512 && val < 828)
				error_msgs.push_back("Are you trying to impress me through your waste of time?");
			else if (val > 828 && val < 1021)
				error_msgs.push_back("This is getting ridiculous.");
			else if (val > 1021 && val < 1372)
				error_msgs.push_back("You may run into some performance issues now, btw");
			else if (val > 1372 && val < 1845)
				error_msgs.push_back("I really don't have time for this.");
			else if (val > 1845)
				error_msgs.push_back("Don't you have hobbies or something!?");
			// Turn error to true in all cases from above
			if (val < 2 || val > 30)
				menu_container[i].error = true;
		} 
		 
		// pixels_needed
		int dis_pix = menu_container[2].display_value;
		if (dis_pix > menu_container[0].display_value && dis_pix > menu_container[1].display_value)
		{
			error_msgs.push_back("A player needs more pixels in a row to win than there are rows and columns.");
			error_msgs.push_back("It is impossible to win.");
			menu_container[2].error = true;
		}
		else if (dis_pix > menu_container[0].display_value || dis_pix > menu_container[1].display_value)
		{
			error_msgs.push_back("The grid size is not large enough in one direction to win.");
			error_msgs.push_back("A game might be harder to win.");
			menu_container[2].error = true;
		}
		 
		if (dis_pix < 2)
		{
			error_msgs.push_back("Pixel streaks lower than 2 may produce unexpected behaviour!");
			menu_container[2].error = true;
		}
		 
		// Pixel color
		if (menu_container[4].text_loc == menu_container[6].text_loc)
		{
			error_msgs.push_back("Having both players with the same color is not recommended");
			menu_container[4].error = true;
			menu_container[6].error = true;
		}
		 
		// Player icons
		if (menu_container[5].text_loc == menu_container[7].text_loc)
		{
			error_msgs.push_back("Having both players with the same icons is not recommended");
			menu_container[5].error = true;
			menu_container[7].error = true;
		}
		 
		 
		//// Print error messages
		erase();
		attron( COLOR_PAIR(2) );
		for (int i = 0; i < error_msgs.size(); i++)
		{
			mvprintw( y_origin + window_rows + 2 + i, x_origin + 3, error_msgs[i].c_str() );
		}
		attroff( COLOR_PAIR(2) );
		 
		 
		 
		///// MENU RENDERING
		 
		// Erase the entire window in case there was a menu entry with a higher digit count before than the one now
		// For example: A value was 10, now the user presses KEY_LEFT, 
		// but the menu shows 90 although it is nine, because the location of the '0' wasn't redrawn
		werase( menu_win );
		// Print a box around the menu window
		box(menu_win, 1, 0);
		 
		// Create a title and some decorations outside of the window
		// I swear this looks halfway decent in the actual menu
		
		// xoxoprint converts the string here to the matching color
		// and character for each player
		// The X's and O's here are just "placeholders"
		xoxoprint( 3, " _____ ___ ____   _____  _    ____   _____ ___  _____ ");
		xoxoprint( 4, "|XOXXO|OXO/XOXO| |OOXOX|/X\\  /XOOX| |OXXOX/OXO\\|XXOXO|");
		xoxoprint( 5, "  |O|  |X|X|       |O| /O_X\\|X|       |X||O| |O|OXO|  ");
		xoxoprint( 6, "  |X|  |O|X|___    |X|/OXOXX\\O|___    |O||O| |O|O|___ ");
		xoxoprint( 7, " |X|  |OO\\OOXX|   |X/O/   \\O\\OXXO|   |X| \\XXO/|OXXOX|");
		
		mvprintw( y_origin-1, x_origin, "Starting a new game:");
		mvwprintw(menu_win, window_rows - 1, window_columns - 10, "<Enter>");
		// Error message if the terminal is too small
		attron(COLOR_PAIR(66));
		if (max_y < 25 || max_x < 70)
			mvprintw(0, 0, "Terminal too small for tictactoe-ncurses.\n You may experience rendering issues");
		attroff(COLOR_PAIR(66));
		 
		// Render window contents
		for (int i = 0; i < menu_container.size(); i++)
		{
			if (selected_entry == i)
			{
				// Render the input indicator 
				 
				 
				// Compute the position the right indicator has to render on
				int digit_size = 1;
				// If the display_text vector is empty, and the number should be shown
				if (menu_container[i].display_text.size() == 0)
				{
					if (menu_container[i].display_value > 9 || menu_container[i].display_value < 0)
						digit_size = 2;
					if (menu_container[i].display_value > 100 || menu_container[i].display_value < -9)
						digit_size = 3;
				}
				else
				{
					digit_size = menu_container[i].display_text[menu_container[i].text_loc].length();
				}
				mvwprintw( menu_win, i + y_borders, dis_val_start - 2, "<");
				mvwprintw( menu_win, i + y_borders, dis_val_start + 1+ digit_size, ">");
				// Activate the standout color pair
				wattron( menu_win, A_STANDOUT );
			}
			 
			// If the current entry is reported erroneous,
			// turn off the standout pair and activate the error color pair
			if (menu_container[i].error == true)
			{
				wattroff( menu_win, A_STANDOUT );
				wattron( menu_win, COLOR_PAIR(66) );
			}
			 
			mvwprintw( menu_win, i + y_borders, 2, menu_container[i].description.c_str() );
			// If the size of the text vector is empty, show the integer
			if (menu_container[i].display_text.size() == 0)
				mvwprintw( menu_win, i + y_borders, dis_val_start, "%d", menu_container[i].display_value );
			else
				// Else, show the text of the current entry
				mvwprintw( menu_win, i + y_borders, dis_val_start, menu_container[i].display_text[menu_container[i].text_loc].c_str() );
			// Turn the possible color pairs off
			wattroff( menu_win, A_STANDOUT );
			wattroff( menu_win, COLOR_PAIR(66) );
			// Reset error value to check if it is still true on the next while iteration
			menu_container[i].error = false;
		}
		refresh();
		wrefresh( menu_win );
		ch = getch();
	}
	// OK, this looks very ugly, but I couldn't find a better solution:
	// Assign every real variable the variable in the vector
	grid_size_y = menu_container[0].display_value;
	grid_size_x = menu_container[1].display_value;
	pixels_needed = menu_container[2].display_value;
	gamemode = menu_container[3].text_loc;
	player_one_color = menu_container[4].text_loc + 1;
	player_one_pixel = menu_container[5].display_text[menu_container[5].text_loc].at(0);
	player_two_color = menu_container[6].text_loc + 1;
	player_two_pixel = menu_container[7].display_text[menu_container[7].text_loc].at(0);
	starting_player = menu_container[8].text_loc + 1;
	// Delete the window and clear the screen
	delwin( menu_win );
	erase();
	return 0;
}

int win_menu()
{
	// Create a new window
	WINDOW *menu_win;
	// Construction variables
	int des_rows = 20, des_cols = 50;
	int y_borders = 7, x_borders = 8;
	int window_rows, window_columns;
	// Determine window sizes
	if (max_y > des_rows + y_borders*2)
		window_rows = des_rows;
	else
		window_rows = max_y - y_borders*2;
	 
	if (max_x > des_cols + x_borders*2)
		window_columns = des_cols;
	else
		window_columns = max_x - x_borders*2;
	int x_origin = (max_x / 2) - ( window_columns / 2), y_origin = y_borders; // Center window horizontally
	menu_win = newwin( window_rows, window_columns, y_origin, x_origin);
	 
	int selected = 0;
	
	 
	// Input
	ch = 0;
	while (ch != 10 && ch != ' ') 
	{
		///// PROCESSING INPUT
		//
		switch (ch)
		{
			case 113:
				delwin(menu_win);
				return 0;
				break;
			case KEY_UP: case 'k':
				selected = 0;
				break;
			case KEY_DOWN: case 'j':
				selected = 1;
				break;
		}
		
		 
		///// RENDERING
		 
		// The most basic renderer because there are only two options
		werase( menu_win );
		if (selected == 0)
		{
			// "Restart" stands out
			// Indicators
			mvwprintw( menu_win, window_rows - 6, window_columns / 2 - 5, "<" );
			mvwprintw( menu_win, window_rows - 6, window_columns / 2 + 5, ">" );
			wattron(menu_win, A_STANDOUT);
			mvwprintw( menu_win, window_rows - 6, window_columns / 2 - 3, "Restart" );
			wattroff(menu_win, A_STANDOUT);
			mvwprintw( menu_win, window_rows - 5, window_columns / 2 - 2, "Quit" );
		}
		else if (selected == 1)
		{
			// "Quit" stands out
			// Indicators
			mvwprintw( menu_win, window_rows - 5, window_columns / 2 - 4, "<" );
			mvwprintw( menu_win, window_rows - 5, window_columns / 2 + 3, ">" );
			mvwprintw( menu_win, window_rows - 6, window_columns / 2 - 3, "Restart" );
			wattron(menu_win, A_STANDOUT);
			mvwprintw( menu_win, window_rows - 5, window_columns / 2 - 2, "Quit" );
			wattroff(menu_win, A_STANDOUT);
		}
		 
		 
		// Make an outline box in the color of the current player
		int color;
		if (current_player == 1)
			color = player_one_color;
		else if (current_player == 2)
			color = player_two_color;
		wattron(menu_win, COLOR_PAIR(color));
		box(menu_win, 0, 0);
		wattroff(menu_win, COLOR_PAIR(color));
		 
		 
		// Win message in yellow
		wattron(menu_win, COLOR_PAIR(4));
		if (gamemode == 0 && current_player == 2)
		{
			mvwprintw( menu_win, 5, window_columns / 2 - 8, "The computer has won!" );
		}
		else if (current_player != -1)
		{
			mvwprintw( menu_win, 5, window_columns / 2 - 8, "Player %d has won!", current_player );
		}
		else
			mvwprintw( menu_win, 5, window_columns / 2 - 14, "The grid is full. It's a tie!" );
		 
		wattroff(menu_win, COLOR_PAIR(4));
		 
		// Some random deco
		wattron( menu_win, COLOR_PAIR(4) );
		mvwprintw( menu_win, 0, 0, "/");
		mvwprintw( menu_win, 0, window_columns - 1, "\\");
		wattroff( menu_win, COLOR_PAIR(4) );
		 
		 
		refresh();
		wrefresh(menu_win);
		 
		// Get input character
		ch = getch(); 
	}
	 
	 
	if (selected == 0) // 'Restart' selected
	{
		// erase the menu on the screen, delete the pointer and render the grid to fill spaces that might have been overwritten
		werase(menu_win);
		wrefresh(menu_win);
		delwin(menu_win);
		render_grid();
		return 1;
	}
	else if (selected == 1) // 'Quit' selected
		return 0;
	// An error must have happened
	delwin(menu_win);
	return -5;
}

void help_text(int start_y, int start_x)
{
	// Gamemode
	mvprintw(start_y, start_x, "You are playing a ");
	attron(A_BOLD); 
	if (gamemode == 0)
		printw("Singleplayer");
	else if (gamemode == 1)
		printw("Multiplayer");
	else
		printw("Oopstheremusthavebeenanerrorbecauseihavenofuckingideowhatgamemodeyourein");
	attroff(A_BOLD);
	printw(" game.\n");
	for (int i = 0; i < start_x; i++)
		printw(" ");
	 
	// Players turn
	if (gamemode == 0)
		printw("It is your turn. The computer doesn't have to think like you inferior humans.\n\n");
	else if (gamemode == 1)
	{
		printw("It is Player ");
		attron(A_BOLD); printw("%d", current_player); attroff(A_BOLD);
		printw("'s turn.\n");
	}
	for (int i = 0; i < start_x; i++)
		printw(" ");
	 
	// pixels_needed
	printw("You need ");
	attron(A_BOLD); printw("%d ", pixels_needed); attroff(A_BOLD);
	printw("pixels in a row to win.\n");
	for (int i = 0; i < start_x; i++)
		printw(" ");
	 
	// Use the Vi keys [ hjkl ] or [ WASD ] to move the cursor.
	printw("Use the Vi keys ");
	attron(A_BOLD); printw("[ hjkl ] "); attroff(A_BOLD);
	printw("or ");
	attron(A_BOLD); printw("[ wasd ] "); attroff(A_BOLD);
	printw("to move the cursor.\n");
	for (int i = 0; i < start_x; i++)
		printw(" ");
	 
	// Confirm your choice with [ Space ] or [ Enter ].
	printw("Confirm your choice with ");
	attron(A_BOLD); printw("[ Space ] "); attroff(A_BOLD);
	printw("or ");
	attron(A_BOLD); printw("[ Enter ]"); attroff(A_BOLD);
	printw(".\n");
	for (int i = 0; i < start_x; i++)
		printw(" ");
	// Quit with [ q ].
	printw("Quit with ");
	attron(A_BOLD); printw("[ q ]"); attroff(A_BOLD);
	printw(".");
}

void render_title(int start_y, int start_x)
{
	// Render the title
	// If we have ASCII art, here will be ASCII art
	move(start_y, start_x);
	int middle = ((grid[0].size() * 6) / 2);
	for (int i = 0; i < grid[0].size(); i++)
	{
		printw("======");
	}
	std::string title = "TIC TAC TOE";
	mvprintw(start_y + 1, (middle - (title.length() / 2)) + start_x, "%s\n",title.c_str());
	move(start_y + 2, start_x);
	for (int i = 0; i < grid[0].size(); i++)
	{
		printw("======");
	}
	printw("\n");
}

// Function for drawing a rectangle without requiring to spawn a window
void make_rectangle(int start_y, int start_x, int end_y, int end_x)
{
	mvhline(start_y ,start_x, 0, end_x-start_x);
	mvhline(end_y, start_x, 0, end_x-start_x);
	mvvline(start_y, start_x, 0, end_y-start_y);
	mvvline(start_y, end_x, 0, end_y-start_y);
	mvaddch(start_y, start_x, ACS_ULCORNER);
	mvaddch(end_y, start_x, ACS_LLCORNER);
	mvaddch(start_y, end_x, ACS_URCORNER);
	mvaddch(end_y, end_x, ACS_LRCORNER);
}

// Function for rendering the grid
void render_grid()
{
	render_title(1, 2);
	int start_y = 5, start_x = 2;
	int y_pos, x_pos;
	// Render the actual grid
	for (int y = 0; y < grid.size(); y++)
	{
		move(start_y + y * 2 + 1, start_x + 1); 
		for (int x = 0; x < grid[0].size(); x++)
		{
			printw(" ");
			// Render selected pixel on the left
			if (get_grid_sel(y, x) == true)
				printw(">");
			else
				printw(" ");
			// Render pixel value
			char this_pixel;
			switch (get_grid_val(y, x))
			{
				case 0:
					this_pixel = empty_pixel;
					break;
				case 1:
					attron(COLOR_PAIR(player_one_color));
					this_pixel = player_one_pixel;
					break;
				case 2:
					attron(COLOR_PAIR(player_two_color));
					this_pixel = player_two_pixel;
					break;
				default:
					this_pixel = unknown_pixel;
			}
			printw("%c", this_pixel);
			attroff(COLOR_PAIR(player_one_color));
			attroff(COLOR_PAIR(player_two_color));
			// Render selected pixel on the right
			if (get_grid_sel(y, x) == true)
				printw("<");
			else
				printw(" ");
			// Render separator
			if (x != grid[0].size() - 1)
			{
				printw(" |");
			}
		}
		// Begin a new line and render the break
		printw("\n");
		if (y != grid.size() - 1)
		{
			getyx(stdscr, y_pos, x_pos);
			move(y_pos, start_x + 1);
			for (int x = 0; x < grid[0].size()-1; x++)
				printw("------");
			// Print one character less on the last x position
			printw("-----");
		}
		// Repeat on a new line
		printw("\n");
	}
	if (current_player == 1)
		attron(COLOR_PAIR(player_one_color));
	else if (current_player == 2)
		attron(COLOR_PAIR(player_two_color));
	make_rectangle(start_y, start_x, start_y + grid.size() * 2, start_x + grid[0].size() * 6);
	if (current_player == 1)
		attron(COLOR_PAIR(player_one_color));
	else if (current_player == 2)
		attron(COLOR_PAIR(player_two_color));
	attroff(COLOR_PAIR(current_player));
	mvprintw(start_y + grid.size() * 2, start_x + 2, "Turn: %d/%d", turn, (grid.size() * grid[0].size())/2);
}

// Function for printing completely centered
void mvcprintw( int pos_y, std::string to_print )
{
	int length = to_print.length();
	mvprintw(pos_y, (max_x / 2) - (length / 2), to_print.c_str());
}

// Characters that render.h uses to render the characters
// Although the values here might seem to affect the entry that start_menu starts with, they are just fallback values
int gamemode = 0; // Gamemode: 0: Singleplayer; 1: Multiplayer;
int starting_player;
int current_player;
char empty_pixel = ' ', unknown_pixel = '?', player_one_pixel = 'X', player_two_pixel = 'O';
int player_one_color = 1, player_two_color = 2;

// Define print_details function
void Pixel::print_details(int row, int col)
{
	mvprintw(row, col, "Value: %d, Selected: %d, Pos_y: %d, Pos_x: %d", value, selected, pos_y, pos_x);
}

void Pixel::set_value(int my_value)
{
	value = my_value;
}

int Pixel::get_value()
{
	return value;
}

void Pixel::set_selected(bool my_selected)
{
	selected = my_selected;
}

bool Pixel::get_selected()
{
	return selected;
}

// Function to get and set Pixel properties safely by avoiding out of bound access
int get_grid_val(int pos_y, int pos_x)
{
	if (pos_y < grid_size_y && pos_x < grid_size_x && pos_y >= 0 && pos_x >= 0)
		return grid[pos_y][pos_x].get_value();
	else
	{
		if (dbg == true)
			mvprintw( max_y - 9, 2, "ERROR! Tried to get value of nonexistent pixel: Y: %d X: %d", pos_y, pos_x);
		return 0;
	}
}

void set_grid_val(int pos_y, int pos_x, int val)
{
	if (pos_y < grid_size_y && pos_x < grid_size_x && pos_y >= 0 && pos_x >= 0)
	{
		grid[pos_y][pos_x].set_value(val);
	}
	else if (dbg == true)
		mvprintw( max_y - 10, 2, "ERROR! Tried to set value of nonexistent pixel: Y: %d X: %d", pos_y, pos_x);
}

int get_grid_sel(int pos_y, int pos_x)
{
	if (pos_y < grid_size_y && pos_x < grid_size_x && pos_y >= 0 && pos_x >= 0)
		return grid[pos_y][pos_x].get_selected();
	else
	{
		if (dbg == true)
			mvprintw( max_y - 11, 2, "ERROR! Tried to get selected of nonexistent pixel: Y: %d X: %d", pos_y, pos_x);
		return 0;
	}
}
 
void set_grid_sel(int pos_y, int pos_x, bool selected)
{
	if (pos_y < grid_size_y && pos_x < grid_size_x && pos_y >= 0 && pos_x >= 0)
		grid[pos_y][pos_x].set_selected(selected);
	else if (dbg == true)
		mvprintw( max_y - 12, 2, "ERROR! Tried to set selected of nonexistent pixel: Y: %d X: %d", pos_y, pos_x);
}

// Class for each Tile on the grid
class Pixel
{
	private:
		int value;
		int selected;
	public:
		int pos_y, pos_x;
		 
		void set_value(int);
		int get_value();
		void set_selected(bool);
		bool get_selected();
		// DEBUG Print the details of a pixel
		void print_details(int,int);
};

// Multidimensional Vector that holds each Pixel
extern std::vector < std::vector<Pixel> > grid;
// Get and set grid values without causing a segfault
int get_grid_val(int, int);
void set_grid_val(int, int, int);
int get_grid_sel(int, int);
void set_grid_sel(int, int, bool);

// Turn count
extern int turn;
extern int ch;

static const unsigned char utfbyte[UTF_SIZ + 1] = {0x80,    0, 0xC0, 0xE0, 0xF0};
static const unsigned char utfmask[UTF_SIZ + 1] = {0xC0, 0x80, 0xE0, 0xF0, 0xF8};
static const long utfmin[UTF_SIZ + 1] = {       0,    0,  0x80,  0x800,  0x10000};
static const long utfmax[UTF_SIZ + 1] = {0x10FFFF, 0x7F, 0x7FF, 0xFFFF, 0x10FFFF};

static long
utf8decodebyte(const char c, size_t *i)
{
	for (*i = 0; *i < (UTF_SIZ + 1); ++(*i))
		if (((unsigned char)c & utfmask[*i]) == utfbyte[*i])
			return (unsigned char)c & ~utfmask[*i];
	return 0;
}

static size_t
utf8validate(long *u, size_t i)
{
	if (!BETWEEN(*u, utfmin[i], utfmax[i]) || BETWEEN(*u, 0xD800, 0xDFFF))
		*u = UTF_INVALID;
	for (i = 1; *u > utfmax[i]; ++i)
		;
	return i;
}

static size_t
utf8decode(const char *c, long *u, size_t clen)
{
	size_t i, j, len, type;
	long udecoded;
	
	*u = UTF_INVALID;
	if (!clen)
		return 0;
	udecoded = utf8decodebyte(c[0], &len);
	if (!BETWEEN(len, 1, UTF_SIZ))
		return 1;
	for (i = 1, j = 1; i < clen && j < len; ++i, ++j) {
		udecoded = (udecoded << 6) | utf8decodebyte(c[i], &type);
		if (type)
			return j;
	}
	if (j < len)
		return 0;
	*u = udecoded;
	utf8validate(u, len);
	
	return len;
}

Drw *
drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h)
{
	Drw *drw = ecalloc(1, sizeof(Drw));
	
	drw->dpy = dpy;
	drw->screen = screen;
	drw->root = root;
	drw->w = w;
	drw->h = h;
	drw->drawable = XCreatePixmap(dpy, root, w, h, DefaultDepth(dpy, screen));
	drw->gc = XCreateGC(dpy, root, 0, NULL);
	XSetLineAttributes(dpy, drw->gc, 1, LineSolid, CapButt, JoinMiter);
	
	return drw;
}

void
drw_resize(Drw *drw, unsigned int w, unsigned int h)
{
	if (!drw)
		return;
	
	drw->w = w;
	drw->h = h;
	if (drw->drawable)
		XFreePixmap(drw->dpy, drw->drawable);
	drw->drawable = XCreatePixmap(drw->dpy, drw->root, w, h, DefaultDepth(drw->dpy, drw->screen));
}

void
drw_free(Drw *drw)
{
	XFreePixmap(drw->dpy, drw->drawable);
	XFreeGC(drw->dpy, drw->gc);
	drw_fontset_free(drw->fonts);
	free(drw);
}

/* This function is an implementation detail. Library users should use
 * drw_fontset_create instead.
 */
static Fnt *
xfont_create(Drw *drw, const char *fontname, FcPattern *fontpattern)
{
	Fnt *font;
	XftFont *xfont = NULL;
	FcPattern *pattern = NULL;
	
	if (fontname) {
		/* Using the pattern found at font->xfont->pattern does not yield the
		 * same substitution results as using the pattern returned by
		 * FcNameParse; using the latter results in the desired fallback
		 * behaviour whereas the former just results in missing-character
		 * rectangles being drawn, at least with some fonts. */
		if (!(xfont = XftFontOpenName(drw->dpy, drw->screen, fontname))) {
			fprintf(stderr, "error, cannot load font from name: '%s'\n", fontname);
			return NULL;
		}
		if (!(pattern = FcNameParse((FcChar8 *) fontname))) {
			fprintf(stderr, "error, cannot parse font name to pattern: '%s'\n", fontname);
			XftFontClose(drw->dpy, xfont);
			return NULL;
		}
	} else if (fontpattern) {
		if (!(xfont = XftFontOpenPattern(drw->dpy, fontpattern))) {
			fprintf(stderr, "error, cannot load font from pattern.\n");
			return NULL;
		}
	} else {
		die("no font specified.");
	}
	
	/* Do not allow using color fonts. This is a workaround for a BadLength
	 * error from Xft with color glyphs. Modelled on the Xterm workaround. See
	 * https://bugzilla.redhat.com/show_bug.cgi?id=1498269
	 * https://lists.suckless.org/dev/1701/30932.html
	 * https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=916349
	 * and lots more all over the internet.
	 */
	FcBool iscol;
	if(FcPatternGetBool(xfont->pattern, FC_COLOR, 0, &iscol) == FcResultMatch && iscol) {
		XftFontClose(drw->dpy, xfont);
		return NULL;
	}
	
	font = ecalloc(1, sizeof(Fnt));
	font->xfont = xfont;
	font->pattern = pattern;
	font->h = xfont->ascent + xfont->descent;
	font->dpy = drw->dpy;
	
	return font;
}

static void
xfont_free(Fnt *font)
{
	if (!font)
		return;
	if (font->pattern)
		FcPatternDestroy(font->pattern);
	XftFontClose(font->dpy, font->xfont);
	free(font);
}

Fnt*
drw_fontset_create(Drw* drw, const char *fonts[], size_t fontcount)
{
	Fnt *cur, *ret = NULL;
	size_t i;
	
	if (!drw || !fonts)
		return NULL;
	
	for (i = 1; i <= fontcount; i++) {
		if ((cur = xfont_create(drw, fonts[fontcount - i], NULL))) {
			cur->next = ret;
			ret = cur;
		}
	}
	return (drw->fonts = ret);
}

void
drw_fontset_free(Fnt *font)
{
	if (font) {
		drw_fontset_free(font->next);
		xfont_free(font);
	}
}

void
drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
{
	if (!drw || !dest || !clrname)
		return;
	
	if (!XftColorAllocName(drw->dpy, DefaultVisual(drw->dpy, drw->screen),
	                       DefaultColormap(drw->dpy, drw->screen),
	                       clrname, dest))
		die("error, cannot allocate color '%s'", clrname);
	dest->pixel |= 0xff << 24;
}

/* Wrapper to create color schemes. The caller has to call free(3) on the
 * returned color scheme when done using it. */
Clr *
drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
{
	size_t i;
	Clr *ret;
	
	/* need at least two colors for a scheme */
	if (!drw || !clrnames || clrcount < 2 || !(ret = ecalloc(clrcount, sizeof(XftColor))))
		return NULL;
	
	for (i = 0; i < clrcount; i++)
		drw_clr_create(drw, &ret[i], clrnames[i]);
	return ret;
}

void
drw_setfontset(Drw *drw, Fnt *set)
{
	if (drw)
		drw->fonts = set;
}

void
drw_setscheme(Drw *drw, Clr *scm)
{
	if (drw)
		drw->scheme = scm;
}

void
drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int invert)
{
	if (!drw || !drw->scheme)
		return;
	XSetForeground(drw->dpy, drw->gc, invert ? drw->scheme[ColBg].pixel : drw->scheme[ColFg].pixel);
	if (filled)
		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
	else
		XDrawRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w - 1, h - 1);
}

int
drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lpad, const char *text, int invert)
{
	char buf[1024];
	int ty;
	unsigned int ew;
	XftDraw *d = NULL;
	Fnt *usedfont, *curfont, *nextfont;
	size_t i, len;
	int utf8strlen, utf8charlen, render = x || y || w || h;
	long utf8codepoint = 0;
	const char *utf8str;
	FcCharSet *fccharset;
	FcPattern *fcpattern;
	FcPattern *match;
	XftResult result;
	int charexists = 0;
	
	if (!drw || (render && !drw->scheme) || !text || !drw->fonts)
		return 0;
	
	if (!render) {
		w = ~w;
	} else {
		XSetForeground(drw->dpy, drw->gc, drw->scheme[invert ? ColFg : ColBg].pixel);
		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
		d = XftDrawCreate(drw->dpy, drw->drawable,
		                  DefaultVisual(drw->dpy, drw->screen),
		                  DefaultColormap(drw->dpy, drw->screen));
		x += lpad;
		w -= lpad;
	}
	
	usedfont = drw->fonts;
	while (1) {
		utf8strlen = 0;
		utf8str = text;
		nextfont = NULL;
		while (*text) {
			utf8charlen = utf8decode(text, &utf8codepoint, UTF_SIZ);
			for (curfont = drw->fonts; curfont; curfont = curfont->next) {
				charexists = charexists || XftCharExists(drw->dpy, curfont->xfont, utf8codepoint);
				if (charexists) {
					if (curfont == usedfont) {
						utf8strlen += utf8charlen;
						text += utf8charlen;
					} else {
						nextfont = curfont;
					}
					break;
				}
			}
	
			if (!charexists || nextfont)
				break;
			else
				charexists = 0;
		}
	
		if (utf8strlen) {
			drw_font_getexts(usedfont, utf8str, utf8strlen, &ew, NULL);
			/* shorten text if necessary */
			for (len = MIN(utf8strlen, sizeof(buf) - 1); len && ew > w; len--)
				drw_font_getexts(usedfont, utf8str, len, &ew, NULL);
	
			if (len) {
				memcpy(buf, utf8str, len);
				buf[len] = '\0';
				if (len < utf8strlen)
					for (i = len; i && i > len - 3; buf[--i] = '.')
						; /* NOP */
	
				if (render) {
					ty = y + (h - usedfont->h) / 2 + usedfont->xfont->ascent;
					XftDrawStringUtf8(d, &drw->scheme[invert ? ColBg : ColFg],
					                  usedfont->xfont, x, ty, (XftChar8 *)buf, len);
				}
				x += ew;
				w -= ew;
			}
		}
	
		if (!*text) {
			break;
		} else if (nextfont) {
			charexists = 0;
			usedfont = nextfont;
		} else {
			/* Regardless of whether or not a fallback font is found, the
			 * character must be drawn. */
			charexists = 1;
	
			fccharset = FcCharSetCreate();
			FcCharSetAddChar(fccharset, utf8codepoint);
	
			if (!drw->fonts->pattern) {
				/* Refer to the comment in xfont_create for more information. */
				die("the first font in the cache must be loaded from a font string.");
			}
	
			fcpattern = FcPatternDuplicate(drw->fonts->pattern);
			FcPatternAddCharSet(fcpattern, FC_CHARSET, fccharset);
			FcPatternAddBool(fcpattern, FC_SCALABLE, FcTrue);
			FcPatternAddBool(fcpattern, FC_COLOR, FcFalse);
	
			FcConfigSubstitute(NULL, fcpattern, FcMatchPattern);
			FcDefaultSubstitute(fcpattern);
			match = XftFontMatch(drw->dpy, drw->screen, fcpattern, &result);
	
			FcCharSetDestroy(fccharset);
			FcPatternDestroy(fcpattern);
	
			if (match) {
				usedfont = xfont_create(drw, NULL, match);
				if (usedfont && XftCharExists(drw->dpy, usedfont->xfont, utf8codepoint)) {
					for (curfont = drw->fonts; curfont->next; curfont = curfont->next)
						; /* NOP */
					curfont->next = usedfont;
				} else {
					xfont_free(usedfont);
					usedfont = drw->fonts;
				}
			}
		}
	}
	if (d)
		XftDrawDestroy(d);
	
	return x + (render ? w : 0);
}

void
drw_map(Drw *drw, Window win, int x, int y, unsigned int w, unsigned int h)
{
	if (!drw)
		return;
	
	XCopyArea(drw->dpy, drw->drawable, win, drw->gc, x, y, w, h, x, y);
	XSync(drw->dpy, False);
}

unsigned int
drw_fontset_getwidth(Drw *drw, const char *text)
{
	if (!drw || !drw->fonts || !text)
		return 0;
	return drw_text(drw, 0, 0, 0, 0, 0, text, 0);
}

void
drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned int *w, unsigned int *h)
{
	XGlyphInfo ext;
	
	if (!font || !text)
		return;
	
	XftTextExtentsUtf8(font->dpy, font->xfont, (XftChar8 *)text, len, &ext);
	if (w)
		*w = ext.xOff;
	if (h)
		*h = font->h;
}

Cur *
drw_cur_create(Drw *drw, int shape)
{
	Cur *cur;
	
	if (!drw || !(cur = ecalloc(1, sizeof(Cur))))
		return NULL;
	
	cur->cursor = XCreateFontCursor(drw->dpy, shape);
	
	return cur;
}

void
drw_cur_free(Drw *drw, Cur *cursor)
{
	if (!cursor)
		return;
	
	XFreeCursor(drw->dpy, cursor->cursor);
	free(cursor);
}

/* enums */
enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
enum { SchemeNorm, SchemeSel, WinCounterScheme}; /* color schemes */
enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
       NetWMFullscreen, NetActiveWindow, NetWMWindowType,
       NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
       ClkClientWin, ClkRootWin, ClkLast }; /* clicks */

/* A random Argument that can be filled
 * with content. Almost all functions
 * want to be fed with this. Not really
 * sure why this uniform format was chosen,
 * though.
 */
typedef union {
	int i;
	unsigned int ui;
	float f;
	const void *v;
} Arg;

typedef struct {
	unsigned int click;
	unsigned int mask;
	unsigned int button;
	void (*func)(const Arg *arg);
	const Arg arg;
} Button;

/* This is definitely the description for
 * a window
 */
typedef struct Monitor Monitor;
typedef struct Client Client;
struct Client {
	char name[256];
	float mina, maxa;
	int x, y, w, h;
	int oldx, oldy, oldw, oldh;
	int basew, baseh, incw, inch, maxw, maxh, minw, minh;
	int bw, oldbw;
	// Tags the client is assigned to
	unsigned int tags;
	// These are handled like bools, but the dwm
	// devs just pretended that bools don't exist
	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
	Client *next;
	Client *snext;
	Monitor *mon;
	/* The Window type is by X11, so the Client is a Window with
	 * some metadata around it
	 */
	Window win;
};

typedef struct {
	unsigned int mod;
	KeySym keysym;
	void (*func)(const Arg *);
	const Arg arg;
} Key;

typedef struct {
	const char *symbol;
	void (*arrange)(Monitor *);
} Layout;

// Struct for every screen
struct Monitor {
	char ltsymbol[16];
	float mfact; /* Size of master area */
	int nmaster; /* Number of clients in master area */
	int num;
	int by;               /* bar geometry */
	int mx, my, mw, mh;   /* screen size */
	int wx, wy, ww, wh;   /* window area  */
	unsigned int seltags;
	unsigned int sellt;
	unsigned int tagset[2];
	// 0 if no bar should be on this monitor, 1 if yes
	int showbar;
	// 0 if bottom, 1 if top
	int topbar;
	// Running windows on this screen
	Client *clients;
	Client *sel;
	Client *stack;
	// Adjacent monitor (linked list)?
	Monitor *next;
	// Window for the bar
	Window barwin;
	const Layout *lt[2];
};

typedef struct {
	const char *class;
	const char *instance;
	const char *title;
	unsigned int tags;
	int isfloating;
	int monitor;
} Rule;

/* function declarations */
static void applyrules(Client *c);
static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
static void arrange(Monitor *m);
static void arrangemon(Monitor *m);
static void attach(Client *c);
static void attachstack(Client *c);
static void buttonpress(XEvent *e);
static void checkotherwm(void);
static void cleanup(void);
static void cleanupmon(Monitor *mon);
static void clientmessage(XEvent *e);
static void configure(Client *c);
static void configurenotify(XEvent *e);
static void configurerequest(XEvent *e);
static Monitor *createmon(void);
static void destroynotify(XEvent *e);
static void detach(Client *c);
static void detachstack(Client *c);
static Monitor *dirtomon(int dir);
static void drawbar(Monitor *m);
static void drawbars(void);
static void enternotify(XEvent *e);
static void expose(XEvent *e);
static void focus(Client *c);
static void focusin(XEvent *e);
static void focusmon(const Arg *arg);
static void focusstack(const Arg *arg);
static Atom getatomprop(Client *c, Atom prop);
static int getrootptr(int *x, int *y);
static long getstate(Window w);
static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
static void grabbuttons(Client *c, int focused);
static void grabkeys(void);
static void incnmaster(const Arg *arg);
static void keypress(XEvent *e);
static void killclient(const Arg *arg);
static void manage(Window w, XWindowAttributes *wa);
static void mappingnotify(XEvent *e);
static void maprequest(XEvent *e);
static void monocle(Monitor *m);
static void motionnotify(XEvent *e);
static void movemouse(const Arg *arg);
static Client *nexttiled(Client *c);
static void pop(Client *);
static void propertynotify(XEvent *e);
static void quit(const Arg *arg);
static Monitor *recttomon(int x, int y, int w, int h);
static void relview(const Arg *arg);
static void resize(Client *c, int x, int y, int w, int h, int interact);
static void resizeclient(Client *c, int x, int y, int w, int h);
static void resizemouse(const Arg *arg);
static void restack(Monitor *m);
static void run(void);
static void scan(void);
static int sendevent(Client *c, Atom proto);
static void sendmon(Client *c, Monitor *m);
static void setclientstate(Client *c, long state);
static void setfocus(Client *c);
static void setfullscreen(Client *c, int fullscreen);
static void setlayout(const Arg *arg);
static void setmfact(const Arg *arg);
static void setup(void);
static void seturgent(Client *c, int urg);
static void showhide(Client *c);
static void sigchld(int unused);
static void spawn(const Arg *arg);
static void tag(const Arg *arg);
static void tagmon(const Arg *arg);
static void tile(Monitor *);
static void togglebar(const Arg *arg);
static void togglefloating(const Arg *arg);
static void togglefull(const Arg *arg);
static void toggletag(const Arg *arg);
static void toggleview(const Arg *arg);
static void unfocus(Client *c, int setfocus);
static void unmanage(Client *c, int destroyed);
static void unmapnotify(XEvent *e);
static void updatebarpos(Monitor *m);
static void updatebars(void);
static void updateclientlist(void);
static int updategeom(void);
static void updatenumlockmask(void);
static void updatesizehints(Client *c);
static void updatestatus(void);
static void updatetitle(Client *c);
static void updatewindowtype(Client *c);
static void updatewmhints(Client *c);
static void view(const Arg *arg);
static Client *wintoclient(Window w);
static Monitor *wintomon(Window w);
static int xerror(Display *dpy, XErrorEvent *ee);
static int xerrordummy(Display *dpy, XErrorEvent *ee);
static int xerrorstart(Display *dpy, XErrorEvent *ee);
static void zoom(const Arg *arg);

/* variables */
static const char broken[] = "broken";
// Status text, the text right at the status bar
// User is supposed to put all their status stuff in there
static char stext[256];
static int screen;
static int sw, sh;           /* X display screen geometry width, height */
static int bh, blw = 0;      /* bar geometry */
static int lrpad;            /* sum of left and right padding for text */
static int (*xerrorxlib)(Display *, XErrorEvent *);
static unsigned int numlockmask = 0;
static void (*handler[LASTEvent]) (XEvent *) = {
	[ButtonPress] = buttonpress,
	[ClientMessage] = clientmessage,
	[ConfigureRequest] = configurerequest,
	[ConfigureNotify] = configurenotify,
	[DestroyNotify] = destroynotify,
	[EnterNotify] = enternotify,
	[Expose] = expose,
	[FocusIn] = focusin,
	[KeyPress] = keypress,
	[MappingNotify] = mappingnotify,
	[MapRequest] = maprequest,
	[MotionNotify] = motionnotify,
	[PropertyNotify] = propertynotify,
	[UnmapNotify] = unmapnotify
};

static Atom wmatom[WMLast], netatom[NetLast];
// If set to 0, dtwm stops
static int running = 1;
static Cur *cursor[CurLast];
static Clr **scheme;
// dpy is the whole display, opened in main()
static Display *dpy;
/* drw is a container for draw properties used
 * by drw functions; For example, when using
 * drw_rect(), the function checks for the color in
 * of drw->scheme, which can be set through drw_setscheme()
 */
static Drw *drw;
// selmon is the Selected Monitor
static Monitor *mons, *selmon;
static Window root, wmcheckwin;

/* function implementations */
void
applyrules(Client *c)
{
	const char *class, *instance;
	unsigned int i;
	const Rule *r;
	Monitor *m;
	XClassHint ch = { NULL, NULL };
	
	/* rule matching */
	c->isfloating = 0;
	c->tags = 0;
	XGetClassHint(dpy, c->win, &ch);
	class    = ch.res_class ? ch.res_class : broken;
	instance = ch.res_name  ? ch.res_name  : broken;
	
	for (i = 0; i < LENGTH(rules); i++) {
		r = &rules[i];
		if ((!r->title || strstr(c->name, r->title))
		&& (!r->class || strstr(class, r->class))
		&& (!r->instance || strstr(instance, r->instance)))
		{
			c->isfloating = r->isfloating;
			c->tags |= r->tags;
			for (m = mons; m && m->num != r->monitor; m = m->next);
			if (m)
				c->mon = m;
		}
	}
	if (ch.res_class)
		XFree(ch.res_class);
	if (ch.res_name)
		XFree(ch.res_name);
	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
}

int
applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact)
{
	int baseismin;
	Monitor *m = c->mon;
	
	/* set minimum possible */
	*w = MAX(1, *w);
	*h = MAX(1, *h);
	if (interact) {
		if (*x > sw)
			*x = sw - WIDTH(c);
		if (*y > sh)
			*y = sh - HEIGHT(c);
		if (*x + *w + 2 * c->bw < 0)
			*x = 0;
		if (*y + *h + 2 * c->bw < 0)
			*y = 0;
	} else {
		if (*x >= m->wx + m->ww)
			*x = m->wx + m->ww - WIDTH(c);
		if (*y >= m->wy + m->wh)
			*y = m->wy + m->wh - HEIGHT(c);
		if (*x + *w + 2 * c->bw <= m->wx)
			*x = m->wx;
		if (*y + *h + 2 * c->bw <= m->wy)
			*y = m->wy;
	}
	if (*h < bh)
		*h = bh;
	if (*w < bh)
		*w = bh;
	if (resizehints || c->isfloating || !c->mon->lt[c->mon->sellt]->arrange) {
		/* see last two sentences in ICCCM 4.1.2.3 */
		baseismin = c->basew == c->minw && c->baseh == c->minh;
		if (!baseismin) { /* temporarily remove base dimensions */
			*w -= c->basew;
			*h -= c->baseh;
		}
		/* adjust for aspect limits */
		if (c->mina > 0 && c->maxa > 0) {
			if (c->maxa < (float)*w / *h)
				*w = *h * c->maxa + 0.5;
			else if (c->mina < (float)*h / *w)
				*h = *w * c->mina + 0.5;
		}
		if (baseismin) { /* increment calculation requires this */
			*w -= c->basew;
			*h -= c->baseh;
		}
		/* adjust for increment value */
		if (c->incw)
			*w -= *w % c->incw;
		if (c->inch)
			*h -= *h % c->inch;
		/* restore base dimensions */
		*w = MAX(*w + c->basew, c->minw);
		*h = MAX(*h + c->baseh, c->minh);
		if (c->maxw)
			*w = MIN(*w, c->maxw);
		if (c->maxh)
			*h = MIN(*h, c->maxh);
	}
	return *x != c->x || *y != c->y || *w != c->w || *h != c->h;
}

void
arrange(Monitor *m)
{
	if (m)
		showhide(m->stack);
	else for (m = mons; m; m = m->next)
		showhide(m->stack);
	if (m) 
	{
		arrangemon(m);
		restack(m);
	} else for (m = mons; m; m = m->next)
		arrangemon(m);
}

void
arrangemon(Monitor *m)
{
	strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, sizeof m->ltsymbol);
	if (m->lt[m->sellt]->arrange)
		m->lt[m->sellt]->arrange(m);
}

void
attach(Client *c)
{
	c->next = c->mon->clients;
	c->mon->clients = c;
}

void
attachstack(Client *c)
{
	c->snext = c->mon->stack;
	c->mon->stack = c;
}

void
buttonpress(XEvent *e)
{
	unsigned int i, x, click;
	Arg arg = {0};
	Client *c;
	Monitor *m;
	XButtonPressedEvent *ev = &e->xbutton;
	
	click = ClkRootWin;
	/* focus monitor if necessary */
	if ((m = wintomon(ev->window)) && m != selmon) {
		unfocus(selmon->sel, 1);
		selmon = m;
		focus(NULL);
	}
	if (ev->window == selmon->barwin) {
		i = x = 0;
		do
			x += TEXTW(tags[i]);
		while (ev->x >= x && ++i < LENGTH(tags));
		if (i < LENGTH(tags)) {
			click = ClkTagBar;
			arg.ui = 1 << i;
		} else if (ev->x < x + blw)
			click = ClkLtSymbol;
		else if (ev->x > selmon->ww - (int)TEXTW(stext))
			click = ClkStatusText;
		else
			click = ClkWinTitle;
	} else if ((c = wintoclient(ev->window))) {
		focus(c);
		restack(selmon);
		XAllowEvents(dpy, ReplayPointer, CurrentTime);
		click = ClkClientWin;
	}
	for (i = 0; i < LENGTH(buttons); i++)
		if (click == buttons[i].click && buttons[i].func && buttons[i].button == ev->button
		&& CLEANMASK(buttons[i].mask) == CLEANMASK(ev->state))
			buttons[i].func(click == ClkTagBar && buttons[i].arg.i == 0 ? &arg : &buttons[i].arg);
}

void
checkotherwm(void)
{
	xerrorxlib = XSetErrorHandler(xerrorstart);
	/* this causes an error if some other window manager is running */
	XSelectInput(dpy, DefaultRootWindow(dpy), SubstructureRedirectMask);
	XSync(dpy, False);
	XSetErrorHandler(xerror);
	XSync(dpy, False);
}

void
cleanup(void)
{
	Arg a = {.ui = ~0};
	Layout foo = { "", NULL };
	Monitor *m;
	size_t i;
	
	view(&a);
	selmon->lt[selmon->sellt] = &foo;
	for (m = mons; m; m = m->next)
		while (m->stack)
			unmanage(m->stack, 0);
	XUngrabKey(dpy, AnyKey, AnyModifier, root);
	while (mons)
		cleanupmon(mons);
	for (i = 0; i < CurLast; i++)
		drw_cur_free(drw, cursor[i]);
	for (i = 0; i < LENGTH(colors); i++)
		free(scheme[i]);
	XDestroyWindow(dpy, wmcheckwin);
	drw_free(drw);
	XSync(dpy, False);
	XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
	XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
}

void
cleanupmon(Monitor *mon)
{
	Monitor *m;
	
	if (mon == mons)
		mons = mons->next;
	else {
		for (m = mons; m && m->next != mon; m = m->next);
		m->next = mon->next;
	}
	XUnmapWindow(dpy, mon->barwin);
	XDestroyWindow(dpy, mon->barwin);
	free(mon);
}

void
clientmessage(XEvent *e)
{
	XClientMessageEvent *cme = &e->xclient;
	Client *c = wintoclient(cme->window);
	
	if (!c)
		return;
	if (cme->message_type == netatom[NetWMState]) {
		if (cme->data.l[1] == netatom[NetWMFullscreen]
		|| cme->data.l[2] == netatom[NetWMFullscreen])
			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
	} else if (cme->message_type == netatom[NetActiveWindow]) {
		if (c != selmon->sel && !c->isurgent)
			seturgent(c, 1);
	}
}

void
configure(Client *c)
{
	XConfigureEvent ce;
	
	ce.type = ConfigureNotify;
	ce.display = dpy;
	ce.event = c->win;
	ce.window = c->win;
	ce.x = c->x;
	ce.y = c->y;
	ce.width = c->w;
	ce.height = c->h;
	ce.border_width = c->bw;
	ce.above = None;
	ce.override_redirect = False;
	XSendEvent(dpy, c->win, False, StructureNotifyMask, (XEvent *)&ce);
}

void
configurenotify(XEvent *e)
{
	Monitor *m;
	Client *c;
	XConfigureEvent *ev = &e->xconfigure;
	int dirty;
	
	/* TODO: updategeom handling sucks, needs to be simplified */
	if (ev->window == root) {
		dirty = (sw != ev->width || sh != ev->height);
		sw = ev->width;
		sh = ev->height;
		if (updategeom() || dirty) {
			drw_resize(drw, sw, bh);
			updatebars();
			for (m = mons; m; m = m->next) {
				for (c = m->clients; c; c = c->next)
					if (c->isfullscreen)
						resizeclient(c, m->mx, m->my, m->mw, m->mh);
				XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
			}
			focus(NULL);
			arrange(NULL);
		}
	}
}

void
configurerequest(XEvent *e)
{
	Client *c;
	Monitor *m;
	XConfigureRequestEvent *ev = &e->xconfigurerequest;
	XWindowChanges wc;
	
	if ((c = wintoclient(ev->window))) {
		if (ev->value_mask & CWBorderWidth)
			c->bw = ev->border_width;
		else if (c->isfloating || !selmon->lt[selmon->sellt]->arrange) {
			m = c->mon;
			if (ev->value_mask & CWX) {
				c->oldx = c->x;
				c->x = m->mx + ev->x;
			}
			if (ev->value_mask & CWY) {
				c->oldy = c->y;
				c->y = m->my + ev->y;
			}
			if (ev->value_mask & CWWidth) {
				c->oldw = c->w;
				c->w = ev->width;
			}
			if (ev->value_mask & CWHeight) {
				c->oldh = c->h;
				c->h = ev->height;
			}
			if ((c->x + c->w) > m->mx + m->mw && c->isfloating)
				c->x = m->mx + (m->mw / 2 - WIDTH(c) / 2); /* center in x direction */
			if ((c->y + c->h) > m->my + m->mh && c->isfloating)
				c->y = m->my + (m->mh / 2 - HEIGHT(c) / 2); /* center in y direction */
			if ((ev->value_mask & (CWX|CWY)) && !(ev->value_mask & (CWWidth|CWHeight)))
				configure(c);
			if (ISVISIBLE(c))
				XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
		} else
			configure(c);
	} else {
		wc.x = ev->x;
		wc.y = ev->y;
		wc.width = ev->width;
		wc.height = ev->height;
		wc.border_width = ev->border_width;
		wc.sibling = ev->above;
		wc.stack_mode = ev->detail;
		XConfigureWindow(dpy, ev->window, ev->value_mask, &wc);
	}
	XSync(dpy, False);
}

Monitor *
createmon(void)
{
	Monitor *m;
	
	m = ecalloc(1, sizeof(Monitor));
	m->tagset[0] = m->tagset[1] = 1;
	m->mfact = mfact;
	m->nmaster = nmaster;
	m->showbar = showbar;
	m->topbar = topbar;
	m->lt[0] = &layouts[0];
	m->lt[1] = &layouts[1 % LENGTH(layouts)];
	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
	return m;
}

void
destroynotify(XEvent *e)
{
	Client *c;
	XDestroyWindowEvent *ev = &e->xdestroywindow;
	
	if ((c = wintoclient(ev->window)))
		unmanage(c, 1);
}

void
detach(Client *c)
{
	Client **tc;
	
	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
	*tc = c->next;
}

void
detachstack(Client *c)
{
	Client **tc, *t;
	
	for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
	*tc = c->snext;
	
	if (c == c->mon->sel) {
		for (t = c->mon->stack; t && !ISVISIBLE(t); t = t->snext);
		c->mon->sel = t;
	}
}

Monitor *
dirtomon(int dir)
{
	Monitor *m = NULL;
	
	if (dir > 0) {
		if (!(m = selmon->next))
			m = mons;
	} else if (selmon == mons)
		for (m = mons; m->next; m = m->next);
	else
		for (m = mons; m->next != selmon; m = m->next);
	return m;
}

// Draw a bar on a monitor, operates from
// left to right
void
drawbar(Monitor *m)
{
	int x, w, tw = 0;
	int boxs = drw->fonts->h / 9;
	int boxw = drw->fonts->h / 6 + 2;
	unsigned int i, occ = 0, urg = 0;
	Client *c;
	
	if (!m->showbar)
		return;
	
	/* draw status first so it can be overdrawn by tags later */
	if (m == selmon) 
	{ /* status is only drawn on selected monitor 
	   * Why though, maybe I should change that
	   */
		drw_setscheme(drw, scheme[SchemeNorm]);
		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
	}
	
	for (c = m->clients; c; c = c->next) 
	{
		occ |= c->tags;
		if (c->isurgent)
			urg |= c->tags;
	}
	 
	x = 0;
	for (i = 0; i < LENGTH(tags); i++) 
	{
		// Width of current tagname
		w = TEXTW(tags[i]);
		// Set appropriate Scheme
		// Ternary if else just checks if tag is selected and puts on the SchemeSel if it is
		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
		// Write the tagname
		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
		// Draw Window Counter
		if (occ & 1 << i)
		{
			/*
			drw_rect(drw, x + boxs, boxs, boxw, boxw,
				// filled checker
				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
				// inverted checker
				urg & 1 << i);
			*/
			/* Having more than 99 clients on a tag causes the program
			 * to crash because of this
			 * Please don't have more than 99 windows on a tag, thank you
			 */
			char text[2]; 
			unsigned int running = 0;
			for (c = m->clients; c; c = c->next)
			{
				/* If the tags assigned to this client
				 * match the current tag
				 */
				if (c->tags & 1 << i)
					running++;
			}
			sprintf(text, "%d", running);
			drw_text(drw, x, 0, (running > 9) ? 16 : 8, 12,
					0, text, 0);
		}
		// Increase x position by width
		x += w;
	}
	 
	// Draw nmaster amount
	if ((m->nmaster > 1 || m->nmaster == 0) && shownmaster)
	{
		x = drw_text(drw, x, 0, TEXTW("||="), bh, lrpad / 2, "||=", 0);
		char text[20];
		if (m->nmaster == 0)
			sprintf(text, "INF");
		else
			sprintf(text, "%d", m->nmaster);
		x = drw_text(drw, x, 0, TEXTW(text), bh, lrpad / 2, text, 0);
	}
	 
	// Draw the layout symbol (e.g. []=)
	w = blw = TEXTW(m->ltsymbol);
	drw_setscheme(drw, scheme[SchemeNorm]);
	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
	
	if ((w = m->ww - tw - x) > bh) 
	{
		if (m->sel) 
		{
			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
			// Draw name of selected client
			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
			if (m->sel->isfloating)
				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
		} 
		else 
		{
			drw_setscheme(drw, scheme[SchemeNorm]);
			drw_rect(drw, x, 0, w, bh, 1, 1);
		}
	}
	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
}

// Draw all bars
void
drawbars(void)
{
	Monitor *m;
	
	for (m = mons; m; m = m->next)
		drawbar(m);
}

void
enternotify(XEvent *e)
{
	Client *c;
	Monitor *m;
	XCrossingEvent *ev = &e->xcrossing;
	
	if ((ev->mode != NotifyNormal || ev->detail == NotifyInferior) && ev->window != root)
		return;
	c = wintoclient(ev->window);
	m = c ? c->mon : wintomon(ev->window);
	if (m != selmon) {
		unfocus(selmon->sel, 1);
		selmon = m;
	} else if (!c || c == selmon->sel)
		return;
	focus(c);
}

void
expose(XEvent *e)
{
	Monitor *m;
	XExposeEvent *ev = &e->xexpose;
	
	if (ev->count == 0 && (m = wintomon(ev->window)))
		drawbar(m);
}

void
focus(Client *c)
{
	if (!c || !ISVISIBLE(c))
		for (c = selmon->stack; c && !ISVISIBLE(c); c = c->snext);
	if (selmon->sel && selmon->sel != c)
		unfocus(selmon->sel, 0);
	if (c) {
		if (c->mon != selmon)
			selmon = c->mon;
		if (c->isurgent)
			seturgent(c, 0);
		detachstack(c);
		attachstack(c);
		grabbuttons(c, 1);
		XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
		setfocus(c);
	} else {
		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
	}
	selmon->sel = c;
	drawbars();
}

/* there are some broken focus acquiring clients needing extra handling */
void
focusin(XEvent *e)
{
	XFocusChangeEvent *ev = &e->xfocus;
	
	if (selmon->sel && ev->window != selmon->sel->win)
		setfocus(selmon->sel);
}

void
focusmon(const Arg *arg)
{
	Monitor *m;
	
	if (!mons->next)
		return;
	if ((m = dirtomon(arg->i)) == selmon)
		return;
	unfocus(selmon->sel, 0);
	selmon = m;
	focus(NULL);
}

void
focusstack(const Arg *arg)
{
	Client *c = NULL, *i;
	
	if (!selmon->sel || (selmon->sel->isfullscreen && lockfullscreen))
		return;
	if (arg->i > 0) {
		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
		if (!c)
			for (c = selmon->clients; c && !ISVISIBLE(c); c = c->next);
	} else {
		for (i = selmon->clients; i != selmon->sel; i = i->next)
			if (ISVISIBLE(i))
				c = i;
		if (!c)
			for (; i; i = i->next)
				if (ISVISIBLE(i))
					c = i;
	}
	if (c) {
		focus(c);
		restack(selmon);
	}
}

Atom
getatomprop(Client *c, Atom prop)
{
	int di;
	unsigned long dl;
	unsigned char *p = NULL;
	Atom da, atom = None;
	
	if (XGetWindowProperty(dpy, c->win, prop, 0L, sizeof atom, False, XA_ATOM,
		&da, &di, &dl, &dl, &p) == Success && p) {
		atom = *(Atom *)p;
		XFree(p);
	}
	return atom;
}

int
getrootptr(int *x, int *y)
{
	int di;
	unsigned int dui;
	Window dummy;
	
	return XQueryPointer(dpy, root, &dummy, &dummy, x, y, &di, &di, &dui);
}

long
getstate(Window w)
{
	int format;
	long result = -1;
	unsigned char *p = NULL;
	unsigned long n, extra;
	Atom real;
	
	if (XGetWindowProperty(dpy, w, wmatom[WMState], 0L, 2L, False, wmatom[WMState],
		&real, &format, &n, &extra, (unsigned char **)&p) != Success)
		return -1;
	if (n != 0)
		result = *p;
	XFree(p);
	return result;
}

int
gettextprop(Window w, Atom atom, char *text, unsigned int size)
{
	char **list = NULL;
	int n;
	XTextProperty name;
	
	if (!text || size == 0)
		return 0;
	text[0] = '\0';
	if (!XGetTextProperty(dpy, w, &name, atom) || !name.nitems)
		return 0;
	if (name.encoding == XA_STRING)
		strncpy(text, (char *)name.value, size - 1);
	else {
		if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success && n > 0 && *list) {
			strncpy(text, *list, size - 1);
			XFreeStringList(list);
		}
	}
	text[size - 1] = '\0';
	XFree(name.value);
	return 1;
}

void
grabbuttons(Client *c, int focused)
{
	updatenumlockmask();
	{
		unsigned int i, j;
		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
		if (!focused)
			XGrabButton(dpy, AnyButton, AnyModifier, c->win, False,
				BUTTONMASK, GrabModeSync, GrabModeSync, None, None);
		for (i = 0; i < LENGTH(buttons); i++)
			if (buttons[i].click == ClkClientWin)
				for (j = 0; j < LENGTH(modifiers); j++)
					XGrabButton(dpy, buttons[i].button,
						buttons[i].mask | modifiers[j],
						c->win, False, BUTTONMASK,
						GrabModeAsync, GrabModeSync, None, None);
	}
}

void
grabkeys(void)
{
	updatenumlockmask();
	{
		unsigned int i, j;
		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
		KeyCode code;
	
		XUngrabKey(dpy, AnyKey, AnyModifier, root);
		for (i = 0; i < LENGTH(keys); i++)
		{
			if ((code = XKeysymToKeycode(dpy, keys[i].keysym)))
			{
				for (j = 0; j < LENGTH(modifiers); j++)
				{
					XGrabKey(dpy, code, keys[i].mod | modifiers[j], root,
						True, GrabModeAsync, GrabModeAsync);
				}
			}
		}
	}
}

void
incnmaster(const Arg *arg)
{
	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
	arrange(selmon);
}

#ifdef XINERAMA
static int
isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
{
	while (n--)
		if (unique[n].x_org == info->x_org && unique[n].y_org == info->y_org
		&& unique[n].width == info->width && unique[n].height == info->height)
			return 0;
	return 1;
}
#endif /* XINERAMA */

void
keypress(XEvent *e)
{
	unsigned int i;
	KeySym keysym;
	XKeyEvent *ev;
	
	ev = &e->xkey;
	keysym = XKeycodeToKeysym(dpy, (KeyCode)ev->keycode, 0);
	for (i = 0; i < LENGTH(keys); i++)
	{
		/* If the pressed key is the keysym (like XK_e or XK_space),
		 * call its function with its arg (man, a function in a 
		 * struct, that's fancy)
		 */
		if (keysym == keys[i].keysym
			&& CLEANMASK(keys[i].mod) == CLEANMASK(ev->state)
			&& keys[i].func)
		{
			keys[i].func(&(keys[i].arg));
		}
	}
}

void
killclient(const Arg *arg)
{
	if (!selmon->sel)
		return;
	if (!sendevent(selmon->sel, wmatom[WMDelete])) {
		XGrabServer(dpy);
		XSetErrorHandler(xerrordummy);
		XSetCloseDownMode(dpy, DestroyAll);
		XKillClient(dpy, selmon->sel->win);
		XSync(dpy, False);
		XSetErrorHandler(xerror);
		XUngrabServer(dpy);
	}
}

void
manage(Window w, XWindowAttributes *wa)
{
	Client *c, *t = NULL;
	Window trans = None;
	XWindowChanges wc;
	
	c = ecalloc(1, sizeof(Client));
	c->win = w;
	/* geometry */
	c->x = c->oldx = wa->x;
	c->y = c->oldy = wa->y;
	c->w = c->oldw = wa->width;
	c->h = c->oldh = wa->height;
	c->oldbw = wa->border_width;
	
	updatetitle(c);
	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
		c->mon = t->mon;
		c->tags = t->tags;
	} else {
		c->mon = selmon;
		applyrules(c);
	}
	
	if (c->x + WIDTH(c) > c->mon->mx + c->mon->mw)
		c->x = c->mon->mx + c->mon->mw - WIDTH(c);
	if (c->y + HEIGHT(c) > c->mon->my + c->mon->mh)
		c->y = c->mon->my + c->mon->mh - HEIGHT(c);
	c->x = MAX(c->x, c->mon->mx);
	/* only fix client y-offset, if the client center might cover the bar */
	c->y = MAX(c->y, ((c->mon->by == c->mon->my) && (c->x + (c->w / 2) >= c->mon->wx)
		&& (c->x + (c->w / 2) < c->mon->wx + c->mon->ww)) ? bh : c->mon->my);
	c->bw = borderpx;
	
	wc.border_width = c->bw;
	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
	XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
	configure(c); /* propagates border_width, if size doesn't change */
	updatewindowtype(c);
	updatesizehints(c);
	updatewmhints(c);
	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
	grabbuttons(c, 0);
	if (!c->isfloating)
		c->isfloating = c->oldstate = trans != None || c->isfixed;
	if (c->isfloating)
		XRaiseWindow(dpy, c->win);
	attach(c);
	attachstack(c);
	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
		(unsigned char *) &(c->win), 1);
	XMoveResizeWindow(dpy, c->win, c->x + 2 * sw, c->y, c->w, c->h); /* some windows require this */
	setclientstate(c, NormalState);
	if (c->mon == selmon)
		unfocus(selmon->sel, 0);
	c->mon->sel = c;
	arrange(c->mon);
	XMapWindow(dpy, c->win);
	focus(NULL);
}

void
mappingnotify(XEvent *e)
{
	XMappingEvent *ev = &e->xmapping;
	
	XRefreshKeyboardMapping(ev);
	if (ev->request == MappingKeyboard)
		grabkeys();
}

void
maprequest(XEvent *e)
{
	static XWindowAttributes wa;
	XMapRequestEvent *ev = &e->xmaprequest;
	
	if (!XGetWindowAttributes(dpy, ev->window, &wa))
		return;
	if (wa.override_redirect)
		return;
	if (!wintoclient(ev->window))
		manage(ev->window, &wa);
}

void
monocle(Monitor *m)
{
	unsigned int n = 0;
	Client *c;
	
	for (c = m->clients; c; c = c->next)
		if (ISVISIBLE(c))
			n++;
	if (n > 0) /* override layout symbol */
		snprintf(m->ltsymbol, sizeof m->ltsymbol, "[%d]", n);
	for (c = nexttiled(m->clients); c; c = nexttiled(c->next))
		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
}

void
motionnotify(XEvent *e)
{
	static Monitor *mon = NULL;
	Monitor *m;
	XMotionEvent *ev = &e->xmotion;
	
	if (ev->window != root)
		return;
	if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
		unfocus(selmon->sel, 1);
		selmon = m;
		focus(NULL);
	}
	mon = m;
}

/* This function get's never called,
 * if I'm not mistaken and the arg is not
 * used in it!?
 */
void
movemouse(const Arg *arg)
{
	int x, y, ocx, ocy, nx, ny;
	Client *c;
	Monitor *m;
	XEvent ev;
	Time lasttime = 0;
	
	if (!(c = selmon->sel))
		return;
	if (c->isfullscreen) /* no support moving fullscreen windows by mouse */
		return;
	restack(selmon);
	ocx = c->x;
	ocy = c->y;
	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
		None, cursor[CurMove]->cursor, CurrentTime) != GrabSuccess)
		return;
	if (!getrootptr(&x, &y))
		return;
	do {
		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
		switch(ev.type) {
		case ConfigureRequest:
		case Expose:
		case MapRequest:
			handler[ev.type](&ev);
			break;
		case MotionNotify:
			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
				continue;
			lasttime = ev.xmotion.time;
	
			nx = ocx + (ev.xmotion.x - x);
			ny = ocy + (ev.xmotion.y - y);
			if (abs(selmon->wx - nx) < snap)
				nx = selmon->wx;
			else if (abs((selmon->wx + selmon->ww) - (nx + WIDTH(c))) < snap)
				nx = selmon->wx + selmon->ww - WIDTH(c);
			if (abs(selmon->wy - ny) < snap)
				ny = selmon->wy;
			else if (abs((selmon->wy + selmon->wh) - (ny + HEIGHT(c))) < snap)
				ny = selmon->wy + selmon->wh - HEIGHT(c);
			if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
			&& (abs(nx - c->x) > snap || abs(ny - c->y) > snap))
				togglefloating(NULL);
			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
				resize(c, nx, ny, c->w, c->h, 1);
			break;
		}
	} while (ev.type != ButtonRelease);
	XUngrabPointer(dpy, CurrentTime);
	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
		sendmon(c, m);
		selmon = m;
		focus(NULL);
	}
}

Client *
nexttiled(Client *c)
{
	for (; c && (c->isfloating || !ISVISIBLE(c)); c = c->next);
	return c;
}

void
pop(Client *c)
{
	detach(c);
	attach(c);
	focus(c);
	arrange(c->mon);
}

void
propertynotify(XEvent *e)
{
	Client *c;
	Window trans;
	XPropertyEvent *ev = &e->xproperty;
	
	if ((ev->window == root) && (ev->atom == XA_WM_NAME))
		updatestatus();
	else if (ev->state == PropertyDelete)
		return; /* ignore */
	else if ((c = wintoclient(ev->window))) {
		switch(ev->atom) {
		default: break;
		case XA_WM_TRANSIENT_FOR:
			if (!c->isfloating && (XGetTransientForHint(dpy, c->win, &trans)) &&
				(c->isfloating = (wintoclient(trans)) != NULL))
				arrange(c->mon);
			break;
		case XA_WM_NORMAL_HINTS:
			updatesizehints(c);
			break;
		case XA_WM_HINTS:
			updatewmhints(c);
			drawbars();
			break;
		}
		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
			updatetitle(c);
			if (c == c->mon->sel)
				drawbar(c->mon);
		}
		if (ev->atom == netatom[NetWMWindowType])
			updatewindowtype(c);
	}
}

/* Initiates program exit by setting
 * running bool to 0
 *
 * Has an input argument but it just... doesn't matter?
 */
void
quit(const Arg *arg)
{
	running = 0;
}

Monitor *
recttomon(int x, int y, int w, int h)
{
	Monitor *m, *r = selmon;
	int a, area = 0;
	
	for (m = mons; m; m = m->next)
		if ((a = INTERSECT(x, y, w, h, m)) > area) {
			area = a;
			r = m;
		}
	return r;
}

// Move all selected tags by arg->i positions
void
relview(const Arg *arg)
{
	static Arg in_arg;
	if (arg->i < 0)
		in_arg.ui = selmon->tagset[selmon->seltags] >> abs(arg->i);
	else if (arg->i > 0)
		in_arg.ui = selmon->tagset[selmon->seltags] << arg->i;
	else
		return;
	// Debug
	flog("relview: ");
	for (int i = 0; i<LENGTH(selmon->tagset); i++)
	{
		char str[12];
		sprintf(str, "%d", selmon->tagset[i]);
		flog(str);
		flog(", ");
	}
	flog("\n");
	// Debug end
	view(&in_arg);
}

void
resize(Client *c, int x, int y, int w, int h, int interact)
{
	if (applysizehints(c, &x, &y, &w, &h, interact))
		resizeclient(c, x, y, w, h);
}

void
resizeclient(Client *c, int x, int y, int w, int h)
{
	XWindowChanges wc;
	
	c->oldx = c->x; c->x = wc.x = x;
	c->oldy = c->y; c->y = wc.y = y;
	c->oldw = c->w; c->w = wc.width = w;
	c->oldh = c->h; c->h = wc.height = h;
	wc.border_width = c->bw;
	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
	configure(c);
	XSync(dpy, False);
}

void
resizemouse(const Arg *arg)
{
	int ocx, ocy, nw, nh;
	Client *c;
	Monitor *m;
	XEvent ev;
	Time lasttime = 0;
	
	if (!(c = selmon->sel))
		return;
	if (c->isfullscreen) /* no support resizing fullscreen windows by mouse */
		return;
	restack(selmon);
	ocx = c->x;
	ocy = c->y;
	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
		None, cursor[CurResize]->cursor, CurrentTime) != GrabSuccess)
		return;
	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
	do {
		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
		switch(ev.type) {
		case ConfigureRequest:
		case Expose:
		case MapRequest:
			handler[ev.type](&ev);
			break;
		case MotionNotify:
			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
				continue;
			lasttime = ev.xmotion.time;
	
			nw = MAX(ev.xmotion.x - ocx - 2 * c->bw + 1, 1);
			nh = MAX(ev.xmotion.y - ocy - 2 * c->bw + 1, 1);
			if (c->mon->wx + nw >= selmon->wx && c->mon->wx + nw <= selmon->wx + selmon->ww
			&& c->mon->wy + nh >= selmon->wy && c->mon->wy + nh <= selmon->wy + selmon->wh)
			{
				if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
				&& (abs(nw - c->w) > snap || abs(nh - c->h) > snap))
					togglefloating(NULL);
			}
			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
				resize(c, c->x, c->y, nw, nh, 1);
			break;
		}
	} while (ev.type != ButtonRelease);
	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
	XUngrabPointer(dpy, CurrentTime);
	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
		sendmon(c, m);
		selmon = m;
		focus(NULL);
	}
}

void
restack(Monitor *m)
{
	Client *c;
	XEvent ev;
	XWindowChanges wc;
	
	drawbar(m);
	if (!m->sel)
		return;
	if (m->sel->isfloating || !m->lt[m->sellt]->arrange)
		XRaiseWindow(dpy, m->sel->win);
	if (m->lt[m->sellt]->arrange) {
		wc.stack_mode = Below;
		wc.sibling = m->barwin;
		for (c = m->stack; c; c = c->snext)
			if (!c->isfloating && ISVISIBLE(c)) {
				XConfigureWindow(dpy, c->win, CWSibling|CWStackMode, &wc);
				wc.sibling = c->win;
			}
	}
	XSync(dpy, False);
	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
}

void
run(void)
{
	XEvent ev;
	/* main event loop */
	XSync(dpy, False);
	while (running && !XNextEvent(dpy, &ev))
		if (handler[ev.type])
			handler[ev.type](&ev); /* call handler */
}

void
scan(void)
{
	unsigned int i, num;
	Window d1, d2, *wins = NULL;
	XWindowAttributes wa;
	
	if (XQueryTree(dpy, root, &d1, &d2, &wins, &num)) {
		for (i = 0; i < num; i++) {
			if (!XGetWindowAttributes(dpy, wins[i], &wa)
			|| wa.override_redirect || XGetTransientForHint(dpy, wins[i], &d1))
				continue;
			if (wa.map_state == IsViewable || getstate(wins[i]) == IconicState)
				manage(wins[i], &wa);
		}
		for (i = 0; i < num; i++) { /* now the transients */
			if (!XGetWindowAttributes(dpy, wins[i], &wa))
				continue;
			if (XGetTransientForHint(dpy, wins[i], &d1)
			&& (wa.map_state == IsViewable || getstate(wins[i]) == IconicState))
				manage(wins[i], &wa);
		}
		if (wins)
			XFree(wins);
	}
}

void
sendmon(Client *c, Monitor *m)
{
	if (c->mon == m)
		return;
	unfocus(c, 1);
	detach(c);
	detachstack(c);
	c->mon = m;
	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
	attach(c);
	attachstack(c);
	focus(NULL);
	arrange(NULL);
}

void
setclientstate(Client *c, long state)
{
	long data[] = { state, None };
	
	XChangeProperty(dpy, c->win, wmatom[WMState], wmatom[WMState], 32,
		PropModeReplace, (unsigned char *)data, 2);
}

int
sendevent(Client *c, Atom proto)
{
	int n;
	Atom *protocols;
	int exists = 0;
	XEvent ev;
	
	if (XGetWMProtocols(dpy, c->win, &protocols, &n)) {
		while (!exists && n--)
			exists = protocols[n] == proto;
		XFree(protocols);
	}
	if (exists) {
		ev.type = ClientMessage;
		ev.xclient.window = c->win;
		ev.xclient.message_type = wmatom[WMProtocols];
		ev.xclient.format = 32;
		ev.xclient.data.l[0] = proto;
		ev.xclient.data.l[1] = CurrentTime;
		XSendEvent(dpy, c->win, False, NoEventMask, &ev);
	}
	return exists;
}

void
setfocus(Client *c)
{
	if (!c->neverfocus) {
		XSetInputFocus(dpy, c->win, RevertToPointerRoot, CurrentTime);
		XChangeProperty(dpy, root, netatom[NetActiveWindow],
			XA_WINDOW, 32, PropModeReplace,
			(unsigned char *) &(c->win), 1);
	}
	sendevent(c, wmatom[WMTakeFocus]);
}

// Supply client and fullscreen state
void
setfullscreen(Client *c, int fullscreen)
{
	if (fullscreen && !c->isfullscreen) {
		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
			PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
		c->isfullscreen = 1;
		c->oldstate = c->isfloating;
		c->oldbw = c->bw;
		c->bw = 0;
		c->isfloating = 1;
		resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
		XRaiseWindow(dpy, c->win);
	} else if (!fullscreen && c->isfullscreen){
		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
			PropModeReplace, (unsigned char*)0, 0);
		c->isfullscreen = 0;
		c->isfloating = c->oldstate;
		c->bw = c->oldbw;
		c->x = c->oldx;
		c->y = c->oldy;
		c->w = c->oldw;
		c->h = c->oldh;
		resizeclient(c, c->x, c->y, c->w, c->h);
		arrange(c->mon);
	}
}

void
setlayout(const Arg *arg)
{
	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
		selmon->sellt ^= 1;
	if (arg && arg->v)
		selmon->lt[selmon->sellt] = (Layout *)arg->v;
	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
	if (selmon->sel)
		arrange(selmon);
	else
		drawbar(selmon);
}

// Sets the master size
/* arg > 1.0 will set mfact absolutely */
void
setmfact(const Arg *arg)
{
	float f;
	
	if (!arg || !selmon->lt[selmon->sellt]->arrange)
		return;
	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
	if (f < 0.05 || f > 0.95)
		return;
	selmon->mfact = f;
	arrange(selmon);
}

void
setup(void)
{
	int i;
	XSetWindowAttributes wa;
	Atom utf8string;
	
	/* clean up any zombies immediately */
	sigchld(0);
	
	/* init screen */
	screen = DefaultScreen(dpy);
	sw = DisplayWidth(dpy, screen);
	sh = DisplayHeight(dpy, screen);
	root = RootWindow(dpy, screen);
	drw = drw_create(dpy, screen, root, sw, sh);
	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
		die("no fonts could be loaded.");
	lrpad = drw->fonts->h;
	bh = drw->fonts->h + 2;
	updategeom();
	/* init atoms */
	utf8string = XInternAtom(dpy, "UTF8_STRING", False);
	wmatom[WMProtocols] = XInternAtom(dpy, "WM_PROTOCOLS", False);
	wmatom[WMDelete] = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
	wmatom[WMState] = XInternAtom(dpy, "WM_STATE", False);
	wmatom[WMTakeFocus] = XInternAtom(dpy, "WM_TAKE_FOCUS", False);
	netatom[NetActiveWindow] = XInternAtom(dpy, "_NET_ACTIVE_WINDOW", False);
	netatom[NetSupported] = XInternAtom(dpy, "_NET_SUPPORTED", False);
	netatom[NetWMName] = XInternAtom(dpy, "_NET_WM_NAME", False);
	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
	/* init cursors */
	cursor[CurNormal] = drw_cur_create(drw, XC_left_ptr);
	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
	/* init appearance */
	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
	for (i = 0; i < LENGTH(colors); i++)
		scheme[i] = drw_scm_create(drw, colors[i], 3);
	/* init bars */
	updatebars();
	updatestatus();
	/* supporting window for NetWMCheck */
	wmcheckwin = XCreateSimpleWindow(dpy, root, 0, 0, 1, 1, 0, 0, 0);
	XChangeProperty(dpy, wmcheckwin, netatom[NetWMCheck], XA_WINDOW, 32,
		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
	XChangeProperty(dpy, wmcheckwin, netatom[NetWMName], utf8string, 8,
		PropModeReplace, (unsigned char *) "dwm", 3);
	XChangeProperty(dpy, root, netatom[NetWMCheck], XA_WINDOW, 32,
		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
	/* EWMH support per view */
	XChangeProperty(dpy, root, netatom[NetSupported], XA_ATOM, 32,
		PropModeReplace, (unsigned char *) netatom, NetLast);
	XDeleteProperty(dpy, root, netatom[NetClientList]);
	/* select events */
	wa.cursor = cursor[CurNormal]->cursor;
	wa.event_mask = SubstructureRedirectMask|SubstructureNotifyMask
		|ButtonPressMask|PointerMotionMask|EnterWindowMask
		|LeaveWindowMask|StructureNotifyMask|PropertyChangeMask;
	XChangeWindowAttributes(dpy, root, CWEventMask|CWCursor, &wa);
	XSelectInput(dpy, root, wa.event_mask);
	grabkeys();
	focus(NULL);
}

void
seturgent(Client *c, int urg)
{
	XWMHints *wmh;
	
	c->isurgent = urg;
	if (!(wmh = XGetWMHints(dpy, c->win)))
		return;
	wmh->flags = urg ? (wmh->flags | XUrgencyHint) : (wmh->flags & ~XUrgencyHint);
	XSetWMHints(dpy, c->win, wmh);
	XFree(wmh);
}

void
showhide(Client *c)
{
	if (!c)
		return;
	if (ISVISIBLE(c)) {
		/* show clients top down */
		XMoveWindow(dpy, c->win, c->x, c->y);
		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
			resize(c, c->x, c->y, c->w, c->h, 0);
		showhide(c->snext);
	} else {
		/* hide clients bottom up */
		showhide(c->snext);
		XMoveWindow(dpy, c->win, WIDTH(c) * -2, c->y);
	}
}

void
sigchld(int unused)
{
	if (signal(SIGCHLD, sigchld) == SIG_ERR)
		die("can't install SIGCHLD handler:");
	while (0 < waitpid(-1, NULL, WNOHANG));
}

// Spawns a shell command (as a new process)
void
spawn(const Arg *arg)
{
	if (arg->v == dmenucmd)
		dmenumon[0] = '0' + selmon->num;
	if (fork() == 0) {
		if (dpy)
			close(ConnectionNumber(dpy));
		setsid();
		execvp(((char **)arg->v)[0], (char **)arg->v);
		fprintf(stderr, "dwm: execvp %s", ((char **)arg->v)[0]);
		perror(" failed");
		exit(EXIT_SUCCESS);
	}
}

// Moves the selected client to the given tag (int)
void
tag(const Arg *arg)
{
	if (selmon->sel && arg->ui & TAGMASK) {
		selmon->sel->tags = arg->ui & TAGMASK;
		focus(NULL);
		arrange(selmon);
	}
}

void
tagmon(const Arg *arg)
{
	if (!selmon->sel || !mons->next)
		return;
	sendmon(selmon->sel, dirtomon(arg->i));
}

void
tile(Monitor *m)
{
	unsigned int i, n, h, mw, my, ty;
	Client *c;
	
	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
	if (n == 0)
		return;
	
	if (n > m->nmaster)
		mw = m->nmaster ? m->ww * m->mfact : 0;
	else
		mw = m->ww;
	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
		if (i < m->nmaster) {
			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
			if (my + HEIGHT(c) < m->wh)
				my += HEIGHT(c);
		} else {
			h = (m->wh - ty) / (n - i);
			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
			if (ty + HEIGHT(c) < m->wh)
				ty += HEIGHT(c);
		}
}

void
togglebar(const Arg *arg)
{
	selmon->showbar = !selmon->showbar;
	updatebarpos(selmon);
	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
	arrange(selmon);
}

void
togglefloating(const Arg *arg)
{
	if (!selmon->sel)
		return;
	if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
		return;
	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
	if (selmon->sel->isfloating)
		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
			selmon->sel->w, selmon->sel->h, 0);
	arrange(selmon);
}

// Toggle fullscreen state of current window
// Just a wrapper for setfullscreen that can be used with keybindings
void
togglefull(const Arg *arg)
{
							   // Just reverse the fullscreen state of the client
	setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
}

// Copies the selected client to a given tag
void
toggletag(const Arg *arg)
{
	unsigned int newtags;
	
	if (!selmon->sel)
		return;
	newtags = selmon->sel->tags ^ (arg->ui & TAGMASK);
	if (newtags) {
		selmon->sel->tags = newtags;
		focus(NULL);
		arrange(selmon);
	}
}

void
toggleview(const Arg *arg)
{
	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
	
	if (newtagset) {
		selmon->tagset[selmon->seltags] = newtagset;
		focus(NULL);
		arrange(selmon);
	}
}

void
unfocus(Client *c, int setfocus)
{
	if (!c)
		return;
	grabbuttons(c, 0);
	XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
	if (setfocus) {
		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
	}
}

void
unmanage(Client *c, int destroyed)
{
	Monitor *m = c->mon;
	XWindowChanges wc;
	
	detach(c);
	detachstack(c);
	if (!destroyed) {
		wc.border_width = c->oldbw;
		XGrabServer(dpy); /* avoid race conditions */
		XSetErrorHandler(xerrordummy);
		XConfigureWindow(dpy, c->win, CWBorderWidth, &wc); /* restore border */
		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
		setclientstate(c, WithdrawnState);
		XSync(dpy, False);
		XSetErrorHandler(xerror);
		XUngrabServer(dpy);
	}
	free(c);
	focus(NULL);
	updateclientlist();
	arrange(m);
}

void
unmapnotify(XEvent *e)
{
	Client *c;
	XUnmapEvent *ev = &e->xunmap;
	
	if ((c = wintoclient(ev->window))) {
		if (ev->send_event)
			setclientstate(c, WithdrawnState);
		else
			unmanage(c, 0);
	}
}

void
updatebars(void)
{
	Monitor *m;
	XSetWindowAttributes wa = {
		.override_redirect = True,
		.background_pixmap = ParentRelative,
		.event_mask = ButtonPressMask|ExposureMask
	};
	XClassHint ch = {"dwm", "dwm"};
	for (m = mons; m; m = m->next) {
		if (m->barwin)
			continue;
		m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, DefaultDepth(dpy, screen),
				CopyFromParent, DefaultVisual(dpy, screen),
				CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
		XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
		XMapRaised(dpy, m->barwin);
		XSetClassHint(dpy, m->barwin, &ch);
	}
}

void
updatebarpos(Monitor *m)
{
	m->wy = m->my;
	m->wh = m->mh;
	if (m->showbar) {
		m->wh -= bh;
		m->by = m->topbar ? m->wy : m->wy + m->wh;
		m->wy = m->topbar ? m->wy + bh : m->wy;
	} else
		m->by = -bh;
}

void
updateclientlist()
{
	Client *c;
	Monitor *m;
	
	XDeleteProperty(dpy, root, netatom[NetClientList]);
	for (m = mons; m; m = m->next)
		for (c = m->clients; c; c = c->next)
			XChangeProperty(dpy, root, netatom[NetClientList],
				XA_WINDOW, 32, PropModeAppend,
				(unsigned char *) &(c->win), 1);
}

int
updategeom(void)
{
	int dirty = 0;
	
#ifdef XINERAMA
	if (XineramaIsActive(dpy)) {
		int i, j, n, nn;
		Client *c;
		Monitor *m;
		XineramaScreenInfo *info = XineramaQueryScreens(dpy, &nn);
		XineramaScreenInfo *unique = NULL;
	
		for (n = 0, m = mons; m; m = m->next, n++);
		/* only consider unique geometries as separate screens */
		unique = ecalloc(nn, sizeof(XineramaScreenInfo));
		for (i = 0, j = 0; i < nn; i++)
			if (isuniquegeom(unique, j, &info[i]))
				memcpy(&unique[j++], &info[i], sizeof(XineramaScreenInfo));
		XFree(info);
		nn = j;
		if (n <= nn) { /* new monitors available */
			for (i = 0; i < (nn - n); i++) {
				for (m = mons; m && m->next; m = m->next);
				if (m)
					m->next = createmon();
				else
					mons = createmon();
			}
			for (i = 0, m = mons; i < nn && m; m = m->next, i++)
				if (i >= n
				|| unique[i].x_org != m->mx || unique[i].y_org != m->my
				|| unique[i].width != m->mw || unique[i].height != m->mh)
				{
					dirty = 1;
					m->num = i;
					m->mx = m->wx = unique[i].x_org;
					m->my = m->wy = unique[i].y_org;
					m->mw = m->ww = unique[i].width;
					m->mh = m->wh = unique[i].height;
					updatebarpos(m);
				}
		} else { /* less monitors available nn < n */
			for (i = nn; i < n; i++) {
				for (m = mons; m && m->next; m = m->next);
				while ((c = m->clients)) {
					dirty = 1;
					m->clients = c->next;
					detachstack(c);
					c->mon = mons;
					attach(c);
					attachstack(c);
				}
				if (m == selmon)
					selmon = mons;
				cleanupmon(m);
			}
		}
		free(unique);
	} else
#endif /* XINERAMA */
	{ /* default monitor setup */
		if (!mons)
			mons = createmon();
		if (mons->mw != sw || mons->mh != sh) {
			dirty = 1;
			mons->mw = mons->ww = sw;
			mons->mh = mons->wh = sh;
			updatebarpos(mons);
		}
	}
	if (dirty) {
		selmon = mons;
		selmon = wintomon(root);
	}
	return dirty;
}

void
updatenumlockmask(void)
{
	unsigned int i, j;
	XModifierKeymap *modmap;
	
	numlockmask = 0;
	modmap = XGetModifierMapping(dpy);
	for (i = 0; i < 8; i++)
		for (j = 0; j < modmap->max_keypermod; j++)
			if (modmap->modifiermap[i * modmap->max_keypermod + j]
				== XKeysymToKeycode(dpy, XK_Num_Lock))
				numlockmask = (1 << i);
	XFreeModifiermap(modmap);
}

void
updatesizehints(Client *c)
{
	long msize;
	XSizeHints size;
	
	if (!XGetWMNormalHints(dpy, c->win, &size, &msize))
		/* size is uninitialized, ensure that size.flags aren't used */
		size.flags = PSize;
	if (size.flags & PBaseSize) {
		c->basew = size.base_width;
		c->baseh = size.base_height;
	} else if (size.flags & PMinSize) {
		c->basew = size.min_width;
		c->baseh = size.min_height;
	} else
		c->basew = c->baseh = 0;
	if (size.flags & PResizeInc) {
		c->incw = size.width_inc;
		c->inch = size.height_inc;
	} else
		c->incw = c->inch = 0;
	if (size.flags & PMaxSize) {
		c->maxw = size.max_width;
		c->maxh = size.max_height;
	} else
		c->maxw = c->maxh = 0;
	if (size.flags & PMinSize) {
		c->minw = size.min_width;
		c->minh = size.min_height;
	} else if (size.flags & PBaseSize) {
		c->minw = size.base_width;
		c->minh = size.base_height;
	} else
		c->minw = c->minh = 0;
	if (size.flags & PAspect) {
		c->mina = (float)size.min_aspect.y / size.min_aspect.x;
		c->maxa = (float)size.max_aspect.x / size.max_aspect.y;
	} else
		c->maxa = c->mina = 0.0;
	c->isfixed = (c->maxw && c->maxh && c->maxw == c->minw && c->maxh == c->minh);
}

void
updatestatus(void)
{
	if (!gettextprop(root, XA_WM_NAME, stext, sizeof(stext)))
		strcpy(stext, "dtwm-"VERSION);
	drawbar(selmon);
}

void
updatetitle(Client *c)
{
	if (!gettextprop(c->win, netatom[NetWMName], c->name, sizeof c->name))
		gettextprop(c->win, XA_WM_NAME, c->name, sizeof c->name);
	if (c->name[0] == '\0') /* hack to mark broken clients */
		strcpy(c->name, broken);
}

void
updatewindowtype(Client *c)
{
	Atom state = getatomprop(c, netatom[NetWMState]);
	Atom wtype = getatomprop(c, netatom[NetWMWindowType]);
	
	if (state == netatom[NetWMFullscreen])
		setfullscreen(c, 1);
	if (wtype == netatom[NetWMWindowTypeDialog])
		c->isfloating = 1;
}

void
updatewmhints(Client *c)
{
	XWMHints *wmh;
	
	if ((wmh = XGetWMHints(dpy, c->win))) {
		if (c == selmon->sel && wmh->flags & XUrgencyHint) {
			wmh->flags &= ~XUrgencyHint;
			XSetWMHints(dpy, c->win, wmh);
		} else
			c->isurgent = (wmh->flags & XUrgencyHint) ? 1 : 0;
		if (wmh->flags & InputHint)
			c->neverfocus = !wmh->input;
		else
			c->neverfocus = 0;
		XFree(wmh);
	}
}

// Moves the view (tag)
void
view(const Arg *arg)
{
	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
		return;
	selmon->seltags ^= 1; /* toggle sel tagset */
	if (arg->ui & TAGMASK)
		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
	focus(NULL);
	arrange(selmon);
}

Client *
wintoclient(Window w)
{
	Client *c;
	Monitor *m;
	
	for (m = mons; m; m = m->next)
		for (c = m->clients; c; c = c->next)
			if (c->win == w)
				return c;
	return NULL;
}

Monitor *
wintomon(Window w)
{
	int x, y;
	Client *c;
	Monitor *m;
	
	if (w == root && getrootptr(&x, &y))
		return recttomon(x, y, 1, 1);
	for (m = mons; m; m = m->next)
		if (w == m->barwin)
			return m;
	if ((c = wintoclient(w)))
		return c->mon;
	return selmon;
}

/* There's no way to check accesses to destroyed windows, thus those cases are
 * ignored (especially on UnmapNotify's). Other types of errors call Xlibs
 * default error handler, which may call exit. */
int
xerror(Display *dpy, XErrorEvent *ee)
{
	if (ee->error_code == BadWindow
	|| (ee->request_code == X_SetInputFocus && ee->error_code == BadMatch)
	|| (ee->request_code == X_PolyText8 && ee->error_code == BadDrawable)
	|| (ee->request_code == X_PolyFillRectangle && ee->error_code == BadDrawable)
	|| (ee->request_code == X_PolySegment && ee->error_code == BadDrawable)
	|| (ee->request_code == X_ConfigureWindow && ee->error_code == BadMatch)
	|| (ee->request_code == X_GrabButton && ee->error_code == BadAccess)
	|| (ee->request_code == X_GrabKey && ee->error_code == BadAccess)
	|| (ee->request_code == X_CopyArea && ee->error_code == BadDrawable))
		return 0;
	fprintf(stderr, "dwm: fatal error: request code=%d, error code=%d\n",
		ee->request_code, ee->error_code);
	return xerrorxlib(dpy, ee); /* may call exit */
}

int
xerrordummy(Display *dpy, XErrorEvent *ee)
{
	return 0;
}

/* Startup Error handler to check if another window manager
 * is already running. */
int
xerrorstart(Display *dpy, XErrorEvent *ee)
{
	die("dwm: another window manager is already running");
	return -1;
}

void
zoom(const Arg *arg)
{
	Client *c = selmon->sel;
	
	if (!selmon->lt[selmon->sellt]->arrange
	|| (selmon->sel && selmon->sel->isfloating))
		return;
	if (c == nexttiled(selmon->clients))
		if (!c || !(c = nexttiled(c->next)))
			return;
	pop(c);
}

int
main(int argc, char *argv[])
{
	flog("Starting dtwm execution\n");
	// CLI Argument handler
	if (argc == 2 && !strcmp("-v", argv[1]))
		die("dtwm-"VERSION);
	else if (argc != 1)
		die("usage: dwm [-v]");
	// Locale warning
	if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
		fputs("warning: no locale support\n", stderr);
	// Opens the display dpy (exits if it can't be opened)
	if (!(dpy = XOpenDisplay(NULL)))
		die("dwm: cannot open display");
	checkotherwm();
	setup();
#ifdef __OpenBSD__
	if (pledge("stdio rpath proc exec", NULL) == -1)
		die("pledge");
#endif /* __OpenBSD__ */
	scan();
	run();
	cleanup();
	XCloseDisplay(dpy);
	return EXIT_SUCCESS;
}

void *
ecalloc(size_t nmemb, size_t size)
{
	void *p;
	 
	if (!(p = calloc(nmemb, size)))
		die("calloc:");
	return p;
}

// Gives an error message and... well... kills itself
void
die(const char *fmt, ...) {
	va_list ap;
	 
	va_start(ap, fmt);
	vfprintf(stderr, fmt, ap);
	va_end(ap);
	 
	if (fmt[0] && fmt[strlen(fmt)-1] == ':') {
		fputc(' ', stderr);
		perror(NULL);
	} else {
		fputc('\n', stderr);
	}
	 
	exit(1);
}

void
flog(char string[250])
{
	FILE *lfile;
	lfile = fopen("/home/dangertech/dtwm.log", "a");
	if (lfile == NULL)
		die("Error: Log file can't be opened");
	fputs(string, lfile);
	fclose(lfile);
}
